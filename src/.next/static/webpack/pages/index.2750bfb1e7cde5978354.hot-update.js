self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./constants.ts":
/*!**********************!*\
  !*** ./constants.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shaders": function() { return /* binding */ shaders; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
var shaders = {
  fbm: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    #ifndef FNC_MOD289\n    #define FNC_MOD289\n    float mod289(in float x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec2 mod289(in vec2 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec3 mod289(in vec3 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec4 mod289(in vec4 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    #endif\n    #ifndef FNC_PERMUTE\n    #define FNC_PERMUTE\n    float permute(in float x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    \n    vec3 permute(in vec3 x) {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 permute(in vec4 x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    #endif\n    \n    #ifndef FNC_TAYLORINVSQRT\n    #define FNC_TAYLORINVSQRT\n    float taylorInvSqrt(in float r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    vec4 taylorInvSqrt(in vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    #endif\n    #ifndef FNC_GRAD4\n    #define FNC_GRAD4\n    vec4 grad4(float j, vec4 ip) {\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n        vec4 p,s;\n    \n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n        s = vec4(lessThan(p, vec4(0.0)));\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    \n        return p;\n    }\n    #endif\n    \n    \n    /*\n    author: [Ian McEwan, Ashima Arts]\n    description: Simplex Noise https://github.com/ashima/webgl-noise\n    use: snoise(<vec2|vec3|vec4> pos)\n    license: |\n      Copyright (C) 2011 Ashima Arts. All rights reserved.\n      Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n      Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n      Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n      Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n      Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n    */\n    \n    #ifndef FNC_SNOISE\n    #define FNC_SNOISE\n    float snoise(in vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        // First corner\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n    \n        // Other corners\n        vec2 i1;\n        //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n        //i1.y = 1.0 - i1.x;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        // x0 = x0 - 0.0 + 0.0 * C.xx ;\n        // x1 = x0 - i1 + 1.0 * C.xx ;\n        // x2 = x0 - 1.0 + 2.0 * C.xx ;\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n    \n        // Permutations\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n    \n        // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    \n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n    \n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    \n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n    \n    \n    float snoise(in vec3 v) {\n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n        // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n        // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n    \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n        // Permutations\n        i = mod289(i);\n        vec4 p = permute( permute( permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n    \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n    \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n    \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n    \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n    \n        //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n    \n        // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n    }\n    \n    float snoise(in vec4 v) {\n        const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                            0.276393202250021,  // 2 * G4\n                            0.414589803375032,  // 3 * G4\n                            -0.447213595499958); // -1 + 4 * G4\n    \n        // First corner\n        vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n        vec4 x0 = v -   i + dot(i, C.xxxx);\n    \n        // Other corners\n    \n        // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n        vec4 i0;\n        vec3 isX = step( x0.yzw, x0.xxx );\n        vec3 isYZ = step( x0.zww, x0.yyz );\n        //  i0.x = dot( isX, vec3( 1.0 ) );\n        i0.x = isX.x + isX.y + isX.z;\n        i0.yzw = 1.0 - isX;\n        //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n        i0.y += isYZ.x + isYZ.y;\n        i0.zw += 1.0 - isYZ.xy;\n        i0.z += isYZ.z;\n        i0.w += 1.0 - isYZ.z;\n    \n        // i0 now contains the unique values 0,1,2,3 in each channel\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n    \n        //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n        //  x1 = x0 - i1  + 1.0 * C.xxxx\n        //  x2 = x0 - i2  + 2.0 * C.xxxx\n        //  x3 = x0 - i3  + 3.0 * C.xxxx\n        //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n        vec4 x1 = x0 - i1 + C.xxxx;\n        vec4 x2 = x0 - i2 + C.yyyy;\n        vec4 x3 = x0 - i3 + C.zzzz;\n        vec4 x4 = x0 + C.wwww;\n    \n        // Permutations\n        i = mod289(i);\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n        vec4 j1 = permute( permute( permute( permute (\n                    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    \n        // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n        // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n    \n        vec4 p0 = grad4(j0,   ip);\n        vec4 p1 = grad4(j1.x, ip);\n        vec4 p2 = grad4(j1.y, ip);\n        vec4 p3 = grad4(j1.z, ip);\n        vec4 p4 = grad4(j1.w, ip);\n    \n        // Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        p4 *= taylorInvSqrt(dot(p4,p4));\n    \n        // Mix contributions from the five corners\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n        m0 = m0 * m0;\n        m1 = m1 * m1;\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                    + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n    }\n    \n    vec3 snoise3( vec3 x ){\n        float s  = snoise(vec3( x ));\n        float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n        float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    vec3 snoise3( vec4 x ){\n        float s  = snoise(vec4( x ));\n        float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n        float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    #endif\n    \n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse; \n    uniform float u_time;\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    \n    #ifndef FBM_OCTAVES\n    #define FBM_OCTAVES 4\n    #endif\n    \n    #ifndef FBM_NOISE_FNC\n    #define FBM_NOISE_FNC(POS_UV) snoise(POS_UV)\n    #endif\n    \n    #ifndef FBM_VALUE_INITIAL\n    #define FBM_VALUE_INITIAL 0.0\n    #endif\n    \n    #ifndef FBM_SCALE_SCALAR\n    #define FBM_SCALE_SCALAR 2.0\n    #endif\n    \n    #ifndef FBM_AMPLITUD_INITIAL\n    #define FBM_AMPLITUD_INITIAL 0.5\n    #endif\n    \n    #ifndef FBM_AMPLITUD_SCALAR\n    #define FBM_AMPLITUD_SCALAR 0.5\n    #endif\n    \n    #ifndef FNC_FBM\n    #define FNC_FBM\n    float fbm(in vec2 st) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(st);\n            st *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    \n    float fbm(in vec3 pos) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(pos);\n            pos *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    #endif\n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        vec2 ratiost = ratio(st, u_resolution);\n    \n    \n        float noise = fbm(vec3(ratiost, u_time/40.));\n        float noise2 = fbm(vec3(ratiost, noise));\n        float noise3 = fbm(vec3(ratiost, noise2));\n        // float noise4 = fbm(vec3(st, noise3)); \n    \n        vec3 color = vec3(0.);\n    \n        color = vec3(ratiost.x,ratiost.y, 1.);\n        color += noise3;\n    \n        color -= distance(vec2(st.y, st.x), vec2(0., st.x))*3.;\n    \n        gl_FragColor = vec4(color,1.);\n    }"
};


;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29uc3RhbnRzLnRzIl0sIm5hbWVzIjpbInNoYWRlcnMiLCJmYm0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBTUEsT0FBTyxHQUFHO0FBQ1pDLEtBQUc7QUFEUyxDQUFoQjtBQStYQSIsImZpbGUiOiJzdGF0aWMvd2VicGFjay9wYWdlcy9pbmRleC4yNzUwYmZiMWU3Y2RlNTk3ODM1NC5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2hhZGVycyA9IHtcclxuICAgIGZibTogYCNpZmRlZiBHTF9FU1xyXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAjZW5kaWZcclxuICAgICNpZm5kZWYgRk5DX01PRDI4OVxyXG4gICAgI2RlZmluZSBGTkNfTU9EMjg5XHJcbiAgICBmbG9hdCBtb2QyODkoaW4gZmxvYXQgeCkge1xyXG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMyIG1vZDI4OShpbiB2ZWMyIHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBtb2QyODkoaW4gdmVjMyB4KSB7XHJcbiAgICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzQgbW9kMjg5KGluIHZlYzQgeCkge1xyXG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZuZGVmIEZOQ19QRVJNVVRFXHJcbiAgICAjZGVmaW5lIEZOQ19QRVJNVVRFXHJcbiAgICBmbG9hdCBwZXJtdXRlKGluIGZsb2F0IHgpIHtcclxuICAgICAgICAgcmV0dXJuIG1vZDI4OSgoKHggKiAzNC4pICsgMS4pKngpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIHBlcm11dGUoaW4gdmVjMyB4KSB7XHJcbiAgICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzQgcGVybXV0ZShpbiB2ZWM0IHgpIHtcclxuICAgICAgICAgcmV0dXJuIG1vZDI4OSgoKHggKiAzNC4pICsgMS4pKngpO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1RBWUxPUklOVlNRUlRcclxuICAgICNkZWZpbmUgRk5DX1RBWUxPUklOVlNRUlRcclxuICAgIGZsb2F0IHRheWxvckludlNxcnQoaW4gZmxvYXQgcikge1xyXG4gICAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IHRheWxvckludlNxcnQoaW4gdmVjNCByKSB7XHJcbiAgICAgIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgICNpZm5kZWYgRk5DX0dSQUQ0XHJcbiAgICAjZGVmaW5lIEZOQ19HUkFENFxyXG4gICAgdmVjNCBncmFkNChmbG9hdCBqLCB2ZWM0IGlwKSB7XHJcbiAgICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAtMS4wKTtcclxuICAgICAgICB2ZWM0IHAscztcclxuICAgIFxyXG4gICAgICAgIHAueHl6ID0gZmxvb3IoIGZyYWN0ICh2ZWMzKGopICogaXAueHl6KSAqIDcuMCkgKiBpcC56IC0gMS4wO1xyXG4gICAgICAgIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XHJcbiAgICAgICAgcyA9IHZlYzQobGVzc1RoYW4ocCwgdmVjNCgwLjApKSk7XHJcbiAgICAgICAgcC54eXogPSBwLnh5eiArIChzLnh5eioyLjAgLSAxLjApICogcy53d3c7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICBcclxuICAgIC8qXHJcbiAgICBhdXRob3I6IFtJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0c11cclxuICAgIGRlc2NyaXB0aW9uOiBTaW1wbGV4IE5vaXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcclxuICAgIHVzZTogc25vaXNlKDx2ZWMyfHZlYzN8dmVjND4gcG9zKVxyXG4gICAgbGljZW5zZTogfFxyXG4gICAgICBDb3B5cmlnaHQgKEMpIDIwMTEgQXNoaW1hIEFydHMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICAgIENvcHlyaWdodCAoQykgMjAxMS0yMDE2IGJ5IFN0ZWZhbiBHdXN0YXZzb24gKENsYXNzaWMgbm9pc2UgYW5kIG90aGVycylcclxuICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gICAgICBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgICAgIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICAgICAgTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgR1BVSW1hZ2UgZnJhbWV3b3JrIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gIFxyXG4gICAgKi9cclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfU05PSVNFXHJcbiAgICAjZGVmaW5lIEZOQ19TTk9JU0VcclxuICAgIGZsb2F0IHNub2lzZShpbiB2ZWMyIHYpIHtcclxuICAgICAgICBjb25zdCB2ZWM0IEMgPSB2ZWM0KDAuMjExMzI0ODY1NDA1MTg3LCAgLy8gKDMuMC1zcXJ0KDMuMCkpLzYuMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4zNjYwMjU0MDM3ODQ0MzksICAvLyAwLjUqKHNxcnQoMy4wKS0xLjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMC41NzczNTAyNjkxODk2MjYsICAvLyAtMS4wICsgMi4wICogQy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAyNDM5MDI0MzkwMjQzOSk7IC8vIDEuMCAvIDQxLjBcclxuICAgICAgICAvLyBGaXJzdCBjb3JuZXJcclxuICAgICAgICB2ZWMyIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSApO1xyXG4gICAgICAgIHZlYzIgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgICAgIHZlYzIgaTE7XHJcbiAgICAgICAgLy9pMS54ID0gc3RlcCggeDAueSwgeDAueCApOyAvLyB4MC54ID4geDAueSA/IDEuMCA6IDAuMFxyXG4gICAgICAgIC8vaTEueSA9IDEuMCAtIGkxLng7XHJcbiAgICAgICAgaTEgPSAoeDAueCA+IHgwLnkpID8gdmVjMigxLjAsIDAuMCkgOiB2ZWMyKDAuMCwgMS4wKTtcclxuICAgICAgICAvLyB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eCA7XHJcbiAgICAgICAgLy8geDEgPSB4MCAtIGkxICsgMS4wICogQy54eCA7XHJcbiAgICAgICAgLy8geDIgPSB4MCAtIDEuMCArIDIuMCAqIEMueHggO1xyXG4gICAgICAgIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcclxuICAgICAgICB4MTIueHkgLT0gaTE7XHJcbiAgICBcclxuICAgICAgICAvLyBQZXJtdXRhdGlvbnNcclxuICAgICAgICBpID0gbW9kMjg5KGkpOyAvLyBBdm9pZCB0cnVuY2F0aW9uIGVmZmVjdHMgaW4gcGVybXV0YXRpb25cclxuICAgICAgICB2ZWMzIHAgPSBwZXJtdXRlKCBwZXJtdXRlKCBpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wICkpXHJcbiAgICAgICAgKyBpLnggKyB2ZWMzKDAuMCwgaTEueCwgMS4wICkpO1xyXG4gICAgXHJcbiAgICAgICAgdmVjMyBtID0gbWF4KDAuNSAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxMi54eSx4MTIueHkpLCBkb3QoeDEyLnp3LHgxMi56dykpLCAwLjApO1xyXG4gICAgICAgIG0gPSBtKm0gO1xyXG4gICAgICAgIG0gPSBtKm0gO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR3JhZGllbnRzOiA0MSBwb2ludHMgdW5pZm9ybWx5IG92ZXIgYSBsaW5lLCBtYXBwZWQgb250byBhIGRpYW1vbmQuXHJcbiAgICAgICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQxICg0MSo3ID0gMjg3KVxyXG4gICAgXHJcbiAgICAgICAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcclxuICAgICAgICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XHJcbiAgICAgICAgdmVjMyBveCA9IGZsb29yKHggKyAwLjUpO1xyXG4gICAgICAgIHZlYzMgYTAgPSB4IC0gb3g7XHJcbiAgICBcclxuICAgICAgICAvLyBOb3JtYWxpc2UgZ3JhZGllbnRzIGltcGxpY2l0bHkgYnkgc2NhbGluZyBtXHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGlvbiBvZjogbSAqPSBpbnZlcnNlc3FydCggYTAqYTAgKyBoKmggKTtcclxuICAgICAgICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ29tcHV0ZSBmaW5hbCBub2lzZSB2YWx1ZSBhdCBQXHJcbiAgICAgICAgdmVjMyBnO1xyXG4gICAgICAgIGcueCAgPSBhMC54ICAqIHgwLnggICsgaC54ICAqIHgwLnk7XHJcbiAgICAgICAgZy55eiA9IGEwLnl6ICogeDEyLnh6ICsgaC55eiAqIHgxMi55dztcclxuICAgICAgICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgZmxvYXQgc25vaXNlKGluIHZlYzMgdikge1xyXG4gICAgICAgIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcclxuICAgICAgICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRmlyc3QgY29ybmVyXHJcbiAgICAgICAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XHJcbiAgICAgICAgdmVjMyB4MCA9ICAgdiAtIGkgKyBkb3QoaSwgQy54eHgpIDtcclxuICAgIFxyXG4gICAgICAgIC8vIE90aGVyIGNvcm5lcnNcclxuICAgICAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcclxuICAgICAgICB2ZWMzIGwgPSAxLjAgLSBnO1xyXG4gICAgICAgIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xyXG4gICAgICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHg7XHJcbiAgICAgICAgLy8gICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHg7XHJcbiAgICAgICAgLy8gICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHg7XHJcbiAgICAgICAgLy8gICB4MyA9IHgwIC0gMS4wICsgMy4wICogQy54eHg7XHJcbiAgICAgICAgdmVjMyB4MSA9IHgwIC0gaTEgKyBDLnh4eDtcclxuICAgICAgICB2ZWMzIHgyID0geDAgLSBpMiArIEMueXl5OyAvLyAyLjAqQy54ID0gMS8zID0gQy55XHJcbiAgICAgICAgdmVjMyB4MyA9IHgwIC0gRC55eXk7ICAgICAgLy8gLTEuMCszLjAqQy54ID0gLTAuNSA9IC1ELnlcclxuICAgIFxyXG4gICAgICAgIC8vIFBlcm11dGF0aW9uc1xyXG4gICAgICAgIGkgPSBtb2QyODkoaSk7XHJcbiAgICAgICAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcclxuICAgICAgICAgICAgICAgICAgICBpLnogKyB2ZWM0KDAuMCwgaTEueiwgaTIueiwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS54ICsgdmVjNCgwLjAsIGkxLngsIGkyLngsIDEuMCApKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEdyYWRpZW50czogN3g3IHBvaW50cyBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLlxyXG4gICAgICAgIC8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0OSAoNDkqNiA9IDI5NClcclxuICAgICAgICBmbG9hdCBuXyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLjAvNy4wXHJcbiAgICAgICAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XHJcbiAgICBcclxuICAgICAgICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxyXG4gICAgXHJcbiAgICAgICAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcclxuICAgICAgICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXHJcbiAgICBcclxuICAgICAgICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XHJcbiAgICAgICAgdmVjNCB5ID0geV8gKm5zLnggKyBucy55eXl5O1xyXG4gICAgICAgIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcclxuICAgIFxyXG4gICAgICAgIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XHJcbiAgICAgICAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcclxuICAgIFxyXG4gICAgICAgIC8vdmVjNCBzMCA9IHZlYzQobGVzc1RoYW4oYjAsMC4wKSkqMi4wIC0gMS4wO1xyXG4gICAgICAgIC8vdmVjNCBzMSA9IHZlYzQobGVzc1RoYW4oYjEsMC4wKSkqMi4wIC0gMS4wO1xyXG4gICAgICAgIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xyXG4gICAgICAgIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xyXG4gICAgICAgIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xyXG4gICAgICAgIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcclxuICAgIFxyXG4gICAgICAgIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XHJcbiAgICAgICAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcclxuICAgICAgICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xyXG4gICAgICAgIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XHJcbiAgICBcclxuICAgICAgICAvL05vcm1hbGlzZSBncmFkaWVudHNcclxuICAgICAgICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcclxuICAgICAgICBwMCAqPSBub3JtLng7XHJcbiAgICAgICAgcDEgKj0gbm9ybS55O1xyXG4gICAgICAgIHAyICo9IG5vcm0uejtcclxuICAgICAgICBwMyAqPSBub3JtLnc7XHJcbiAgICBcclxuICAgICAgICAvLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcclxuICAgICAgICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcclxuICAgICAgICBtID0gbSAqIG07XHJcbiAgICAgICAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZsb2F0IHNub2lzZShpbiB2ZWM0IHYpIHtcclxuICAgICAgICBjb25zdCB2ZWM0ICBDID0gdmVjNCggMC4xMzgxOTY2MDExMjUwMTEsICAvLyAoNSAtIHNxcnQoNSkpLzIwICBHNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4yNzYzOTMyMDIyNTAwMjEsICAvLyAyICogRzRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxyXG4gICAgXHJcbiAgICAgICAgLy8gRmlyc3QgY29ybmVyXHJcbiAgICAgICAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNCguMzA5MDE2OTk0Mzc0OTQ3NDUxKSkgKTsgLy8gKHNxcnQoNSkgLSAxKS80XHJcbiAgICAgICAgdmVjNCB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eHh4KTtcclxuICAgIFxyXG4gICAgICAgIC8vIE90aGVyIGNvcm5lcnNcclxuICAgIFxyXG4gICAgICAgIC8vIFJhbmsgc29ydGluZyBvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJpbGwgTGljZWEtS2FuZSwgQU1EIChmb3JtZXJseSBBVEkpXHJcbiAgICAgICAgdmVjNCBpMDtcclxuICAgICAgICB2ZWMzIGlzWCA9IHN0ZXAoIHgwLnl6dywgeDAueHh4ICk7XHJcbiAgICAgICAgdmVjMyBpc1laID0gc3RlcCggeDAuend3LCB4MC55eXogKTtcclxuICAgICAgICAvLyAgaTAueCA9IGRvdCggaXNYLCB2ZWMzKCAxLjAgKSApO1xyXG4gICAgICAgIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XHJcbiAgICAgICAgaTAueXp3ID0gMS4wIC0gaXNYO1xyXG4gICAgICAgIC8vICBpMC55ICs9IGRvdCggaXNZWi54eSwgdmVjMiggMS4wICkgKTtcclxuICAgICAgICBpMC55ICs9IGlzWVoueCArIGlzWVoueTtcclxuICAgICAgICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xyXG4gICAgICAgIGkwLnogKz0gaXNZWi56O1xyXG4gICAgICAgIGkwLncgKz0gMS4wIC0gaXNZWi56O1xyXG4gICAgXHJcbiAgICAgICAgLy8gaTAgbm93IGNvbnRhaW5zIHRoZSB1bmlxdWUgdmFsdWVzIDAsMSwyLDMgaW4gZWFjaCBjaGFubmVsXHJcbiAgICAgICAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcclxuICAgICAgICB2ZWM0IGkyID0gY2xhbXAoIGkwLTEuMCwgMC4wLCAxLjAgKTtcclxuICAgICAgICB2ZWM0IGkxID0gY2xhbXAoIGkwLTIuMCwgMC4wLCAxLjAgKTtcclxuICAgIFxyXG4gICAgICAgIC8vICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHh4XHJcbiAgICAgICAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDIgPSB4MCAtIGkyICArIDIuMCAqIEMueHh4eFxyXG4gICAgICAgIC8vICB4MyA9IHgwIC0gaTMgICsgMy4wICogQy54eHh4XHJcbiAgICAgICAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcclxuICAgICAgICB2ZWM0IHgxID0geDAgLSBpMSArIEMueHh4eDtcclxuICAgICAgICB2ZWM0IHgyID0geDAgLSBpMiArIEMueXl5eTtcclxuICAgICAgICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcclxuICAgICAgICB2ZWM0IHg0ID0geDAgKyBDLnd3d3c7XHJcbiAgICBcclxuICAgICAgICAvLyBQZXJtdXRhdGlvbnNcclxuICAgICAgICBpID0gbW9kMjg5KGkpO1xyXG4gICAgICAgIGZsb2F0IGowID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShpLncpICsgaS56KSArIGkueSkgKyBpLngpO1xyXG4gICAgICAgIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcclxuICAgICAgICAgICAgICAgICAgICBpLncgKyB2ZWM0KGkxLncsIGkyLncsIGkzLncsIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnogKyB2ZWM0KGkxLnosIGkyLnosIGkzLnosIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnkgKyB2ZWM0KGkxLnksIGkyLnksIGkzLnksIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnggKyB2ZWM0KGkxLngsIGkyLngsIGkzLngsIDEuMCApKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEdyYWRpZW50czogN3g3eDYgcG9pbnRzIG92ZXIgYSBjdWJlLCBtYXBwZWQgb250byBhIDQtY3Jvc3MgcG9seXRvcGVcclxuICAgICAgICAvLyA3KjcqNiA9IDI5NCwgd2hpY2ggaXMgY2xvc2UgdG8gdGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OS5cclxuICAgICAgICB2ZWM0IGlwID0gdmVjNCgxLjAvMjk0LjAsIDEuMC80OS4wLCAxLjAvNy4wLCAwLjApIDtcclxuICAgIFxyXG4gICAgICAgIHZlYzQgcDAgPSBncmFkNChqMCwgICBpcCk7XHJcbiAgICAgICAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcclxuICAgICAgICB2ZWM0IHAyID0gZ3JhZDQoajEueSwgaXApO1xyXG4gICAgICAgIHZlYzQgcDMgPSBncmFkNChqMS56LCBpcCk7XHJcbiAgICAgICAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcclxuICAgIFxyXG4gICAgICAgIC8vIE5vcm1hbGlzZSBncmFkaWVudHNcclxuICAgICAgICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcclxuICAgICAgICBwMCAqPSBub3JtLng7XHJcbiAgICAgICAgcDEgKj0gbm9ybS55O1xyXG4gICAgICAgIHAyICo9IG5vcm0uejtcclxuICAgICAgICBwMyAqPSBub3JtLnc7XHJcbiAgICAgICAgcDQgKj0gdGF5bG9ySW52U3FydChkb3QocDQscDQpKTtcclxuICAgIFxyXG4gICAgICAgIC8vIE1peCBjb250cmlidXRpb25zIGZyb20gdGhlIGZpdmUgY29ybmVyc1xyXG4gICAgICAgIHZlYzMgbTAgPSBtYXgoMC42IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpKSwgMC4wKTtcclxuICAgICAgICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XHJcbiAgICAgICAgbTAgPSBtMCAqIG0wO1xyXG4gICAgICAgIG0xID0gbTEgKiBtMTtcclxuICAgICAgICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcclxuICAgICAgICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzMgc25vaXNlMyggdmVjMyB4ICl7XHJcbiAgICAgICAgZmxvYXQgcyAgPSBzbm9pc2UodmVjMyggeCApKTtcclxuICAgICAgICBmbG9hdCBzMSA9IHNub2lzZSh2ZWMzKCB4LnkgLSAxOS4xICwgeC56ICsgMzMuNCAsIHgueCArIDQ3LjIgKSk7XHJcbiAgICAgICAgZmxvYXQgczIgPSBzbm9pc2UodmVjMyggeC56ICsgNzQuMiAsIHgueCAtIDEyNC41ICwgeC55ICsgOTkuNCApKTtcclxuICAgICAgICB2ZWMzIGMgPSB2ZWMzKCBzICwgczEgLCBzMiApO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIHNub2lzZTMoIHZlYzQgeCApe1xyXG4gICAgICAgIGZsb2F0IHMgID0gc25vaXNlKHZlYzQoIHggKSk7XHJcbiAgICAgICAgZmxvYXQgczEgPSBzbm9pc2UodmVjNCggeC55IC0gMTkuMSAsIHgueiArIDMzLjQgLCB4LnggKyA0Ny4yLCB4LncgKSk7XHJcbiAgICAgICAgZmxvYXQgczIgPSBzbm9pc2UodmVjNCggeC56ICsgNzQuMiAsIHgueCAtIDEyNC41ICwgeC55ICsgOTkuNCwgeC53ICkpO1xyXG4gICAgICAgIHZlYzMgYyA9IHZlYzMoIHMgLCBzMSAsIHMyICk7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICBcclxuICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XHJcbiAgICB1bmlmb3JtIHZlYzIgdV9tb3VzZTsgXHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcclxuICAgIHZlYzIgcmF0aW8oaW4gdmVjMiBzdCwgaW4gdmVjMiBzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1peCggdmVjMigoc3QueCpzLngvcy55KS0ocy54Ki41LXMueSouNSkvcy55LHN0LnkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIoc3QueCxzdC55KihzLnkvcy54KS0ocy55Ki41LXMueCouNSkvcy54KSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVwKHMueCxzLnkpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fT0NUQVZFU1xyXG4gICAgI2RlZmluZSBGQk1fT0NUQVZFUyA0XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fTk9JU0VfRk5DXHJcbiAgICAjZGVmaW5lIEZCTV9OT0lTRV9GTkMoUE9TX1VWKSBzbm9pc2UoUE9TX1VWKVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX1ZBTFVFX0lOSVRJQUxcclxuICAgICNkZWZpbmUgRkJNX1ZBTFVFX0lOSVRJQUwgMC4wXHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fU0NBTEVfU0NBTEFSXHJcbiAgICAjZGVmaW5lIEZCTV9TQ0FMRV9TQ0FMQVIgMi4wXHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fQU1QTElUVURfSU5JVElBTFxyXG4gICAgI2RlZmluZSBGQk1fQU1QTElUVURfSU5JVElBTCAwLjVcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9BTVBMSVRVRF9TQ0FMQVJcclxuICAgICNkZWZpbmUgRkJNX0FNUExJVFVEX1NDQUxBUiAwLjVcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19GQk1cclxuICAgICNkZWZpbmUgRk5DX0ZCTVxyXG4gICAgZmxvYXQgZmJtKGluIHZlYzIgc3QpIHtcclxuICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xyXG4gICAgICAgIGZsb2F0IHZhbHVlID0gRkJNX1ZBTFVFX0lOSVRJQUw7XHJcbiAgICAgICAgZmxvYXQgYW1wbGl0dWQgPSBGQk1fQU1QTElUVURfSU5JVElBTDtcclxuICAgIFxyXG4gICAgICAgIC8vIExvb3Agb2Ygb2N0YXZlc1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRkJNX09DVEFWRVM7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZSArPSBhbXBsaXR1ZCAqIEZCTV9OT0lTRV9GTkMoc3QpO1xyXG4gICAgICAgICAgICBzdCAqPSBGQk1fU0NBTEVfU0NBTEFSO1xyXG4gICAgICAgICAgICBhbXBsaXR1ZCAqPSBGQk1fQU1QTElUVURfU0NBTEFSO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZsb2F0IGZibShpbiB2ZWMzIHBvcykge1xyXG4gICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBGQk1fVkFMVUVfSU5JVElBTDtcclxuICAgICAgICBmbG9hdCBhbXBsaXR1ZCA9IEZCTV9BTVBMSVRVRF9JTklUSUFMO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTG9vcCBvZiBvY3RhdmVzXHJcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGQk1fT0NUQVZFUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IGFtcGxpdHVkICogRkJNX05PSVNFX0ZOQyhwb3MpO1xyXG4gICAgICAgICAgICBwb3MgKj0gRkJNX1NDQUxFX1NDQUxBUjtcclxuICAgICAgICAgICAgYW1wbGl0dWQgKj0gRkJNX0FNUExJVFVEX1NDQUxBUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICB2ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3VfcmVzb2x1dGlvbi54eTtcclxuICAgICAgICB2ZWMyIHJhdGlvc3QgPSByYXRpbyhzdCwgdV9yZXNvbHV0aW9uKTtcclxuICAgIFxyXG4gICAgXHJcbiAgICAgICAgZmxvYXQgbm9pc2UgPSBmYm0odmVjMyhyYXRpb3N0LCB1X3RpbWUvNDAuKSk7XHJcbiAgICAgICAgZmxvYXQgbm9pc2UyID0gZmJtKHZlYzMocmF0aW9zdCwgbm9pc2UpKTtcclxuICAgICAgICBmbG9hdCBub2lzZTMgPSBmYm0odmVjMyhyYXRpb3N0LCBub2lzZTIpKTtcclxuICAgICAgICAvLyBmbG9hdCBub2lzZTQgPSBmYm0odmVjMyhzdCwgbm9pc2UzKSk7IFxyXG4gICAgXHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgY29sb3IgPSB2ZWMzKHJhdGlvc3QueCxyYXRpb3N0LnksIDEuKTtcclxuICAgICAgICBjb2xvciArPSBub2lzZTM7XHJcbiAgICBcclxuICAgICAgICBjb2xvciAtPSBkaXN0YW5jZSh2ZWMyKHN0LnksIHN0LngpLCB2ZWMyKDAuLCBzdC54KSkqMy47XHJcbiAgICBcclxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLDEuKTtcclxuICAgIH1gXHJcbn1cclxuXHJcblxyXG5leHBvcnQge3NoYWRlcnN9Il0sInNvdXJjZVJvb3QiOiIifQ==