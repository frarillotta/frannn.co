self["webpackHotUpdate_N_E"]("pages/work",{

/***/ "./constants.tsx":
/*!***********************!*\
  !*** ./constants.tsx ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shaders": function() { return /* binding */ shaders; },
/* harmony export */   "p5": function() { return /* binding */ p5; },
/* harmony export */   "roles": function() { return /* binding */ roles; },
/* harmony export */   "terms": function() { return /* binding */ terms; },
/* harmony export */   "homepageText": function() { return /* binding */ homepageText; },
/* harmony export */   "aboutPageContent": function() { return /* binding */ aboutPageContent; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "../node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Anchor/Anchor */ "./components/Anchor/Anchor.tsx");
/* harmony import */ var _components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Shader/Shader */ "./components/Shader/Shader.tsx");
/* harmony import */ var _components_TextCarousel_TextCarousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/TextCarousel/TextCarousel */ "./components/TextCarousel/TextCarousel.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\frari\\Desktop\\dev\\personal-site\\src\\constants.tsx";



var shaders = {
  fullscreenFbm: {
    fragmentShader: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    #ifndef FNC_MOD289\n    #define FNC_MOD289\n    float mod289(in float x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec2 mod289(in vec2 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec3 mod289(in vec3 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec4 mod289(in vec4 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    #endif\n    #ifndef FNC_PERMUTE\n    #define FNC_PERMUTE\n    float permute(in float x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    \n    vec3 permute(in vec3 x) {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 permute(in vec4 x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    #endif\n    \n    #ifndef FNC_TAYLORINVSQRT\n    #define FNC_TAYLORINVSQRT\n    float taylorInvSqrt(in float r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    vec4 taylorInvSqrt(in vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    #endif\n    #ifndef FNC_GRAD4\n    #define FNC_GRAD4\n    vec4 grad4(float j, vec4 ip) {\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n        vec4 p,s;\n    \n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n        s = vec4(lessThan(p, vec4(0.0)));\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    \n        return p;\n    }\n    #endif\n    \n    \n    /*\n    author: [Ian McEwan, Ashima Arts]\n    description: Simplex Noise https://github.com/ashima/webgl-noise\n    use: snoise(<vec2|vec3|vec4> pos)\n    license: |\n      Copyright (C) 2011 Ashima Arts. All rights reserved.\n      Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n      Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n      Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n      Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n      Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n    */\n    \n    #ifndef FNC_SNOISE\n    #define FNC_SNOISE\n    float snoise(in vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        // First corner\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n    \n        // Other corners\n        vec2 i1;\n        //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n        //i1.y = 1.0 - i1.x;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        // x0 = x0 - 0.0 + 0.0 * C.xx ;\n        // x1 = x0 - i1 + 1.0 * C.xx ;\n        // x2 = x0 - 1.0 + 2.0 * C.xx ;\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n    \n        // Permutations\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n    \n        // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    \n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n    \n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    \n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n    \n    \n    float snoise(in vec3 v) {\n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n        // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n        // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n    \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n        // Permutations\n        i = mod289(i);\n        vec4 p = permute( permute( permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n    \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n    \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n    \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n    \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n    \n        //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n    \n        // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n    }\n    \n    float snoise(in vec4 v) {\n        const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                            0.276393202250021,  // 2 * G4\n                            0.414589803375032,  // 3 * G4\n                            -0.447213595499958); // -1 + 4 * G4\n    \n        // First corner\n        vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n        vec4 x0 = v -   i + dot(i, C.xxxx);\n    \n        // Other corners\n    \n        // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n        vec4 i0;\n        vec3 isX = step( x0.yzw, x0.xxx );\n        vec3 isYZ = step( x0.zww, x0.yyz );\n        //  i0.x = dot( isX, vec3( 1.0 ) );\n        i0.x = isX.x + isX.y + isX.z;\n        i0.yzw = 1.0 - isX;\n        //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n        i0.y += isYZ.x + isYZ.y;\n        i0.zw += 1.0 - isYZ.xy;\n        i0.z += isYZ.z;\n        i0.w += 1.0 - isYZ.z;\n    \n        // i0 now contains the unique values 0,1,2,3 in each channel\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n    \n        //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n        //  x1 = x0 - i1  + 1.0 * C.xxxx\n        //  x2 = x0 - i2  + 2.0 * C.xxxx\n        //  x3 = x0 - i3  + 3.0 * C.xxxx\n        //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n        vec4 x1 = x0 - i1 + C.xxxx;\n        vec4 x2 = x0 - i2 + C.yyyy;\n        vec4 x3 = x0 - i3 + C.zzzz;\n        vec4 x4 = x0 + C.wwww;\n    \n        // Permutations\n        i = mod289(i);\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n        vec4 j1 = permute( permute( permute( permute (\n                    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    \n        // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n        // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n    \n        vec4 p0 = grad4(j0,   ip);\n        vec4 p1 = grad4(j1.x, ip);\n        vec4 p2 = grad4(j1.y, ip);\n        vec4 p3 = grad4(j1.z, ip);\n        vec4 p4 = grad4(j1.w, ip);\n    \n        // Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        p4 *= taylorInvSqrt(dot(p4,p4));\n    \n        // Mix contributions from the five corners\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n        m0 = m0 * m0;\n        m1 = m1 * m1;\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                    + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n    }\n    \n    vec3 snoise3( vec3 x ){\n        float s  = snoise(vec3( x ));\n        float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n        float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    vec3 snoise3( vec4 x ){\n        float s  = snoise(vec4( x ));\n        float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n        float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    #endif\n    \n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse; \n    uniform float u_time;\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    \n    #ifndef FBM_OCTAVES\n    #define FBM_OCTAVES 4\n    #endif\n    \n    #ifndef FBM_NOISE_FNC\n    #define FBM_NOISE_FNC(POS_UV) snoise(POS_UV)\n    #endif\n    \n    #ifndef FBM_VALUE_INITIAL\n    #define FBM_VALUE_INITIAL 0.0\n    #endif\n    \n    #ifndef FBM_SCALE_SCALAR\n    #define FBM_SCALE_SCALAR 2.0\n    #endif\n    \n    #ifndef FBM_AMPLITUD_INITIAL\n    #define FBM_AMPLITUD_INITIAL 0.5\n    #endif\n    \n    #ifndef FBM_AMPLITUD_SCALAR\n    #define FBM_AMPLITUD_SCALAR 0.5\n    #endif\n    \n    #ifndef FNC_FBM\n    #define FNC_FBM\n    float fbm(in vec2 st) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(st);\n            st *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    \n    float fbm(in vec3 pos) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(pos);\n            pos *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    #endif\n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        st = ratio(st, u_resolution);\n    \n        float n = 0.4 + snoise(vec3(st, u_time)) * 0.8;\n    \n        float noise = fbm(vec3(st, u_time/10.));\n        float noise2 = fbm(vec3(st, noise));\n        float noise3 = fbm(vec3(st, noise2));\n        float noise4 = fbm(vec3(st, noise3));\n    \n        vec3 color = vec3(st.x,st.y, 1.);\n    \n        color += noise4;\n    \n        gl_FragColor = vec4(color,1.0);\n    }"
  },
  raymarching: {
    fragmentShader: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    uniform vec2 u_resolution;\n    uniform float u_time;\n    float PI = 3.14155925;\n    \n    #ifndef FNC_RATIO\n    #define FNC_RATIO\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    #endif\n    \n    \n    \n    float sdSphere(vec3 p, float r) {\n        return length(p)-r;\n    }\n    \n    mat4 rotationMatrix(vec3 axis, float angle) {\n        axis = normalize(axis);\n        float s = sin(angle);\n        float c = cos(angle);\n        float oc = 1.0 - c;\n        \n        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                    0.0,                                0.0,                                0.0,                                1.0);\n    }\n    \n    vec3 rotate(vec3 v, vec3 axis, float angle) {\n      mat4 m = rotationMatrix(axis, angle);\n      return (m * vec4(v, 1.0)).xyz;\n    }\n    \n    float sdBox( vec3 p, vec3 b )\n    {\n      vec3 q = abs(p) - b;\n      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    // polynomial smooth min (k = 0.1);\n    float smin( float a, float b, float k )\n    {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n    }\n    \n    float sdf(vec3 p) {\n        vec3 p1 = rotate(p, vec3(1.), u_time/2.);\n        // float box = sdBox(p1, vec3(0.3));\n        float box = smin(sdBox(p1, vec3(0.2)), sdSphere(p, 0.2), .2);\n    \n        float sphere = sdSphere(p - vec3(.5, .491, 0.), 0.2);\n    \n        return smin(box, sphere, .4);\n    }\n    \n    vec3 calcNormal( in vec3 p ) // for function f(p)\n    {\n        const float eps = 0.0001; // or some other value\n        const vec2 h = vec2(eps,0);\n        return normalize( vec3(sdf(p+h.xyy) - sdf(p-h.xyy),\n                               sdf(p+h.yxy) - sdf(p-h.yxy),\n                               sdf(p+h.yyx) - sdf(p-h.yyx) ) );\n    }\n    \n    \n    \n    float luma(vec3 color) {\n      return dot(color, vec3(0.299, 0.587, 0.114));\n    }\n    \n    float luma(vec4 color) {\n      return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    }\n    \n    \n    float dither8x8(vec2 position, float brightness) {\n      int x = int(mod(position.x, 8.0));\n      int y = int(mod(position.y, 8.0));\n      int index = x + y * 8;\n      float limit = 0.0;\n    \n      if (x < 8) {\n        if (index == 0) limit = 0.015625;\n        if (index == 1) limit = 0.515625;\n        if (index == 2) limit = 0.140625;\n        if (index == 3) limit = 0.640625;\n        if (index == 4) limit = 0.046875;\n        if (index == 5) limit = 0.546875;\n        if (index == 6) limit = 0.171875;\n        if (index == 7) limit = 0.671875;\n        if (index == 8) limit = 0.765625;\n        if (index == 9) limit = 0.265625;\n        if (index == 10) limit = 0.890625;\n        if (index == 11) limit = 0.390625;\n        if (index == 12) limit = 0.796875;\n        if (index == 13) limit = 0.296875;\n        if (index == 14) limit = 0.921875;\n        if (index == 15) limit = 0.421875;\n        if (index == 16) limit = 0.203125;\n        if (index == 17) limit = 0.703125;\n        if (index == 18) limit = 0.078125;\n        if (index == 19) limit = 0.578125;\n        if (index == 20) limit = 0.234375;\n        if (index == 21) limit = 0.734375;\n        if (index == 22) limit = 0.109375;\n        if (index == 23) limit = 0.609375;\n        if (index == 24) limit = 0.953125;\n        if (index == 25) limit = 0.453125;\n        if (index == 26) limit = 0.828125;\n        if (index == 27) limit = 0.328125;\n        if (index == 28) limit = 0.984375;\n        if (index == 29) limit = 0.484375;\n        if (index == 30) limit = 0.859375;\n        if (index == 31) limit = 0.359375;\n        if (index == 32) limit = 0.0625;\n        if (index == 33) limit = 0.5625;\n        if (index == 34) limit = 0.1875;\n        if (index == 35) limit = 0.6875;\n        if (index == 36) limit = 0.03125;\n        if (index == 37) limit = 0.53125;\n        if (index == 38) limit = 0.15625;\n        if (index == 39) limit = 0.65625;\n        if (index == 40) limit = 0.8125;\n        if (index == 41) limit = 0.3125;\n        if (index == 42) limit = 0.9375;\n        if (index == 43) limit = 0.4375;\n        if (index == 44) limit = 0.78125;\n        if (index == 45) limit = 0.28125;\n        if (index == 46) limit = 0.90625;\n        if (index == 47) limit = 0.40625;\n        if (index == 48) limit = 0.25;\n        if (index == 49) limit = 0.75;\n        if (index == 50) limit = 0.125;\n        if (index == 51) limit = 0.625;\n        if (index == 52) limit = 0.21875;\n        if (index == 53) limit = 0.71875;\n        if (index == 54) limit = 0.09375;\n        if (index == 55) limit = 0.59375;\n        if (index == 56) limit = 1.0;\n        if (index == 57) limit = 0.5;\n        if (index == 58) limit = 0.875;\n        if (index == 59) limit = 0.375;\n        if (index == 60) limit = 0.96875;\n        if (index == 61) limit = 0.46875;\n        if (index == 62) limit = 0.84375;\n        if (index == 63) limit = 0.34375;\n      }\n    \n      return brightness < limit ? 0.0 : 1.0;\n    }\n    \n    vec3 dither8x8(vec2 position, vec3 color) {\n      return color * dither8x8(position, luma(color));\n    }\n    \n    vec4 dither8x8(vec2 position, vec4 color) {\n      return vec4(color.rgb * dither8x8(position, luma(color)), 1.0);\n    }\n    \n    \n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        st = ratio(st, u_resolution);\n        vec3 color = vec3(0.);\n    \n        float dist = length(st - vec2(0.5));\n        vec3 bg = mix(vec3(0.), vec3(.3), dist);\n        vec3 camPos = vec3(0., 0., 3.);\n        vec3 ray = normalize(vec3(st - .5, -1.5));\n    \n        vec3 rayPos = camPos;\n        float t = 0.;\n        float tMax = 5.;\n        for (int i = 0; i < 256; i++) {\n            vec3 pos = camPos + t*ray;\n            float h = sdf(pos);\n            if (h < 0.0001 || t > tMax) {\n                break; \n            }\n            t += h;\n        }\n    \n        // color = bg; \n    \n        if (t < tMax) {\n            vec3 pos = camPos + t*ray;\n            color = vec3(1.);\n            vec3 normal = calcNormal(pos);\n            color = normal;\n            float diff = dot(vec3(1.), normal);\n            color = vec3(diff);\n            float fresnel = pow(1. + dot(ray, normal), 1.);\n            color = vec3(fresnel);\n            color = mix(color, bg, -fresnel);\n        }\n    \n    \n        gl_FragColor = vec4(color,1.0);\n    }"
  },
  fbm: {
    fragmentShader: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    #ifndef FNC_MOD289\n    #define FNC_MOD289\n    float mod289(in float x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec2 mod289(in vec2 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec3 mod289(in vec3 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec4 mod289(in vec4 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    #endif\n    #ifndef FNC_PERMUTE\n    #define FNC_PERMUTE\n    float permute(in float x) {\n        return mod289(((x * 34.) + 1.)*x);\n    }\n    \n    vec3 permute(in vec3 x) {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 permute(in vec4 x) {\n        return mod289(((x * 34.) + 1.)*x);\n    }\n    #endif\n    \n    #ifndef FNC_TAYLORINVSQRT\n    #define FNC_TAYLORINVSQRT\n    float taylorInvSqrt(in float r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    vec4 taylorInvSqrt(in vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    #endif\n    #ifndef FNC_GRAD4\n    #define FNC_GRAD4\n    vec4 grad4(float j, vec4 ip) {\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n        vec4 p,s;\n    \n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n        s = vec4(lessThan(p, vec4(0.0)));\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    \n        return p;\n    }\n    #endif\n    \n    \n    /*\n    author: [Ian McEwan, Ashima Arts]\n    description: Simplex Noise https://github.com/ashima/webgl-noise\n    use: snoise(<vec2|vec3|vec4> pos)\n    license: |\n      Copyright (C) 2011 Ashima Arts. All rights reserved.\n      Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n      Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n      Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n      Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n      Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n    */\n    \n    #ifndef FNC_SNOISE\n    #define FNC_SNOISE\n    float snoise(in vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        // First corner\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n    \n        // Other corners\n        vec2 i1;\n        //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n        //i1.y = 1.0 - i1.x;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        // x0 = x0 - 0.0 + 0.0 * C.xx ;\n        // x1 = x0 - i1 + 1.0 * C.xx ;\n        // x2 = x0 - 1.0 + 2.0 * C.xx ;\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n    \n        // Permutations\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n    \n        // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    \n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n    \n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    \n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n    \n    \n    float snoise(in vec3 v) {\n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n        // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n        // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n    \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n        // Permutations\n        i = mod289(i);\n        vec4 p = permute( permute( permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n    \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n    \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n    \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n    \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n    \n        //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n    \n        // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n    }\n    \n    float snoise(in vec4 v) {\n        const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                            0.276393202250021,  // 2 * G4\n                            0.414589803375032,  // 3 * G4\n                            -0.447213595499958); // -1 + 4 * G4\n    \n        // First corner\n        vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n        vec4 x0 = v -   i + dot(i, C.xxxx);\n    \n        // Other corners\n    \n        // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n        vec4 i0;\n        vec3 isX = step( x0.yzw, x0.xxx );\n        vec3 isYZ = step( x0.zww, x0.yyz );\n        //  i0.x = dot( isX, vec3( 1.0 ) );\n        i0.x = isX.x + isX.y + isX.z;\n        i0.yzw = 1.0 - isX;\n        //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n        i0.y += isYZ.x + isYZ.y;\n        i0.zw += 1.0 - isYZ.xy;\n        i0.z += isYZ.z;\n        i0.w += 1.0 - isYZ.z;\n    \n        // i0 now contains the unique values 0,1,2,3 in each channel\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n    \n        //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n        //  x1 = x0 - i1  + 1.0 * C.xxxx\n        //  x2 = x0 - i2  + 2.0 * C.xxxx\n        //  x3 = x0 - i3  + 3.0 * C.xxxx\n        //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n        vec4 x1 = x0 - i1 + C.xxxx;\n        vec4 x2 = x0 - i2 + C.yyyy;\n        vec4 x3 = x0 - i3 + C.zzzz;\n        vec4 x4 = x0 + C.wwww;\n    \n        // Permutations\n        i = mod289(i);\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n        vec4 j1 = permute( permute( permute( permute (\n                    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    \n        // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n        // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n    \n        vec4 p0 = grad4(j0,   ip);\n        vec4 p1 = grad4(j1.x, ip);\n        vec4 p2 = grad4(j1.y, ip);\n        vec4 p3 = grad4(j1.z, ip);\n        vec4 p4 = grad4(j1.w, ip);\n    \n        // Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        p4 *= taylorInvSqrt(dot(p4,p4));\n    \n        // Mix contributions from the five corners\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n        m0 = m0 * m0;\n        m1 = m1 * m1;\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                    + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n    }\n    \n    vec3 snoise3( vec3 x ){\n        float s  = snoise(vec3( x ));\n        float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n        float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    vec3 snoise3( vec4 x ){\n        float s  = snoise(vec4( x ));\n        float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n        float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    #endif\n    \n    \n    uniform vec2 u_resolution;\n    uniform float u_time;\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    \n    #ifndef FBM_OCTAVES\n    #define FBM_OCTAVES 4\n    #endif\n    \n    #ifndef FBM_NOISE_FNC\n    #define FBM_NOISE_FNC(POS_UV) snoise(POS_UV)\n    #endif\n    \n    #ifndef FBM_VALUE_INITIAL\n    #define FBM_VALUE_INITIAL 0.0\n    #endif\n    \n    #ifndef FBM_SCALE_SCALAR\n    #define FBM_SCALE_SCALAR 2.0\n    #endif\n    \n    #ifndef FBM_AMPLITUD_INITIAL\n    #define FBM_AMPLITUD_INITIAL 0.5\n    #endif\n    \n    #ifndef FBM_AMPLITUD_SCALAR\n    #define FBM_AMPLITUD_SCALAR 0.5\n    #endif\n    \n    #ifndef FNC_FBM\n    #define FNC_FBM\n    float fbm(in vec2 st) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(st);\n            st *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    \n    float fbm(in vec3 pos) {\n        // Initial values\n        float value = FBM_VALUE_INITIAL;\n        float amplitud = FBM_AMPLITUD_INITIAL;\n    \n        // Loop of octaves\n        for (int i = 0; i < FBM_OCTAVES; i++) {\n            value += amplitud * FBM_NOISE_FNC(pos);\n            pos *= FBM_SCALE_SCALAR;\n            amplitud *= FBM_AMPLITUD_SCALAR;\n        }\n        return value;\n    }\n    #endif\n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        vec2 ratiost = ratio(st, u_resolution);\n    \n    \n        float noise = fbm(vec3(ratiost, u_time/40.));\n        float noise2 = fbm(vec3(ratiost, noise));\n        float noise3 = fbm(vec3(ratiost, noise2));\n    \n        vec3 color = vec3(0.);\n    \n        color = vec3(ratiost.x,ratiost.y, 1.);\n        color += noise3;\n    \n        color -= distance(vec2(st.y, st.x), vec2(0., st.x))*3.;\n    \n        gl_FragColor = vec4(color,1.);\n    }"
  },
  template: {
    fragmentShader: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse; \n    uniform float u_time;\n    \n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n    \n        color = vec3(st.x,st.y,abs(sin(u_time)));\n    \n        gl_FragColor = vec4(color,1.0);\n    }"
  },
  ditherTexture: {
    fragmentShader: "// Author:\n    // Title:\n    \n    precision mediump float;\n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse; \n    uniform float u_time;\n    \n    uniform sampler2D u_texture_1;\n    uniform vec2 u_texture_1_Resolution;\n    \n    \n    float luma(vec3 color) {\n      return dot(color, vec3(0.299, 0.587, 0.114));\n    }\n    \n    float luma(vec4 color) {\n      return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    }\n    \n    \n    float dither8x8(vec2 position, float brightness) {\n      int x = int(mod(position.x, 8.0));\n      int y = int(mod(position.y, 8.0));\n      int index = x + y * 8;\n      float limit = 0.0;\n    \n      if (x < 8) {\n        if (index == 0) limit = 0.015625;\n        if (index == 1) limit = 0.515625;\n        if (index == 2) limit = 0.140625;\n        if (index == 3) limit = 0.640625;\n        if (index == 4) limit = 0.046875;\n        if (index == 5) limit = 0.546875;\n        if (index == 6) limit = 0.171875;\n        if (index == 7) limit = 0.671875;\n        if (index == 8) limit = 0.765625;\n        if (index == 9) limit = 0.265625;\n        if (index == 10) limit = 0.890625;\n        if (index == 11) limit = 0.390625;\n        if (index == 12) limit = 0.796875;\n        if (index == 13) limit = 0.296875;\n        if (index == 14) limit = 0.921875;\n        if (index == 15) limit = 0.421875;\n        if (index == 16) limit = 0.203125;\n        if (index == 17) limit = 0.703125;\n        if (index == 18) limit = 0.078125;\n        if (index == 19) limit = 0.578125;\n        if (index == 20) limit = 0.234375;\n        if (index == 21) limit = 0.734375;\n        if (index == 22) limit = 0.109375;\n        if (index == 23) limit = 0.609375;\n        if (index == 24) limit = 0.953125;\n        if (index == 25) limit = 0.453125;\n        if (index == 26) limit = 0.828125;\n        if (index == 27) limit = 0.328125;\n        if (index == 28) limit = 0.984375;\n        if (index == 29) limit = 0.484375;\n        if (index == 30) limit = 0.859375;\n        if (index == 31) limit = 0.359375;\n        if (index == 32) limit = 0.0625;\n        if (index == 33) limit = 0.5625;\n        if (index == 34) limit = 0.1875;\n        if (index == 35) limit = 0.6875;\n        if (index == 36) limit = 0.03125;\n        if (index == 37) limit = 0.53125;\n        if (index == 38) limit = 0.15625;\n        if (index == 39) limit = 0.65625;\n        if (index == 40) limit = 0.8125;\n        if (index == 41) limit = 0.3125;\n        if (index == 42) limit = 0.9375;\n        if (index == 43) limit = 0.4375;\n        if (index == 44) limit = 0.78125;\n        if (index == 45) limit = 0.28125;\n        if (index == 46) limit = 0.90625;\n        if (index == 47) limit = 0.40625;\n        if (index == 48) limit = 0.25;\n        if (index == 49) limit = 0.75;\n        if (index == 50) limit = 0.125;\n        if (index == 51) limit = 0.625;\n        if (index == 52) limit = 0.21875;\n        if (index == 53) limit = 0.71875;\n        if (index == 54) limit = 0.09375;\n        if (index == 55) limit = 0.59375;\n        if (index == 56) limit = 1.0;\n        if (index == 57) limit = 0.5;\n        if (index == 58) limit = 0.875;\n        if (index == 59) limit = 0.375;\n        if (index == 60) limit = 0.96875;\n        if (index == 61) limit = 0.46875;\n        if (index == 62) limit = 0.84375;\n        if (index == 63) limit = 0.34375;\n      }\n    \n      return brightness < limit ? 0.0 : 1.0;\n    }\n    \n    vec3 dither8x8(vec2 position, vec3 color) {\n      return color * dither8x8(position, luma(color));\n    }\n    \n    vec4 dither8x8(vec2 position, vec4 color) {\n      return vec4(color.rgb * dither8x8(position, luma(color)), 1.0);\n    }\n    \n    \n    #ifndef FNC_RATIO\n    #define FNC_RATIO\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    #endif\n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        st = ratio(st, u_resolution);\n        vec4 color = vec4(st.x,st.y,0.0,1.0);\n    \n    \n        float grid = u_resolution.x/3.5;\n        vec2 st_f = fract(st);\n        vec2 st_i = floor(st * grid)/grid;\n        // st_i = st;\n        \n        // color = vec4(st.x,st.y,abs(sin(u_time)), 1.);\n        color = texture2D(u_texture_1,st_i);\n        color = vec4(dither8x8(gl_FragCoord.xy, color));\n    \n    \n        gl_FragColor = color;\n    }",
    texture: "/assets/pictures/a.jpg"
  },
  simplexNoise: {
    fragmentShader: " #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    \n    #ifndef FNC_RATIO\n    #define FNC_RATIO\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    #endif\n    #ifndef FNC_HSV2RGB\n    #define FNC_HSV2RGB\n    vec3 hsv2rgb(in vec3 hsb) {\n        vec3 rgb = clamp(abs(mod(hsb.x * 6. + vec3(0., 4., 2.), \n                                6.) - 3.) - 1.,\n                          0.,\n                          1.);\n        #ifdef HSV2RGB_SMOOTH\n        rgb = rgb*rgb*(3. - 2. * rgb);\n        #endif\n        return hsb.z * mix(vec3(1.), rgb, hsb.y);\n    }\n    \n    vec4 hsv2rgb(in vec4 hsb) {\n        return vec4(hsv2rgb(hsb.rgb), hsb.a);\n    }\n    #endif\n    \n    #ifndef FNC_MOD289\n    #define FNC_MOD289\n    float mod289(in float x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec2 mod289(in vec2 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec3 mod289(in vec3 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    \n    vec4 mod289(in vec4 x) {\n      return x - floor(x * (1. / 289.)) * 289.;\n    }\n    #endif\n    \n    #ifndef FNC_PERMUTE\n    #define FNC_PERMUTE\n    float permute(in float x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    \n    vec3 permute(in vec3 x) {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 permute(in vec4 x) {\n         return mod289(((x * 34.) + 1.)*x);\n    }\n    #endif\n    \n    \n    #ifndef FNC_TAYLORINVSQRT\n    #define FNC_TAYLORINVSQRT\n    float taylorInvSqrt(in float r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    vec4 taylorInvSqrt(in vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    #endif\n    \n    #ifndef FNC_GRAD4\n    #define FNC_GRAD4\n    vec4 grad4(float j, vec4 ip) {\n        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n        vec4 p,s;\n    \n        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n        s = vec4(lessThan(p, vec4(0.0)));\n        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    \n        return p;\n    }\n    #endif\n    \n    \n    /*\n    author: [Ian McEwan, Ashima Arts]\n    description: Simplex Noise https://github.com/ashima/webgl-noise\n    use: snoise(<vec2|vec3|vec4> pos)\n    license: |\n      Copyright (C) 2011 Ashima Arts. All rights reserved.\n      Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n      Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n      Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n      Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n      Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  \n    */\n    \n    #ifndef FNC_SNOISE\n    #define FNC_SNOISE\n    float snoise(in vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        // First corner\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n    \n        // Other corners\n        vec2 i1;\n        //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n        //i1.y = 1.0 - i1.x;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        // x0 = x0 - 0.0 + 0.0 * C.xx ;\n        // x1 = x0 - i1 + 1.0 * C.xx ;\n        // x2 = x0 - 1.0 + 2.0 * C.xx ;\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n    \n        // Permutations\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n    \n        // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    \n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n    \n        // Normalise gradients implicitly by scaling m\n        // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    \n        // Compute final noise value at P\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n    \n    \n    float snoise(in vec3 v) {\n        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n        // First corner\n        vec3 i  = floor(v + dot(v, C.yyy) );\n        vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n        // Other corners\n        vec3 g = step(x0.yzx, x0.xyz);\n        vec3 l = 1.0 - g;\n        vec3 i1 = min( g.xyz, l.zxy );\n        vec3 i2 = max( g.xyz, l.zxy );\n    \n        //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n        //   x1 = x0 - i1  + 1.0 * C.xxx;\n        //   x2 = x0 - i2  + 2.0 * C.xxx;\n        //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n        vec3 x1 = x0 - i1 + C.xxx;\n        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n        // Permutations\n        i = mod289(i);\n        vec4 p = permute( permute( permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n        float n_ = 0.142857142857; // 1.0/7.0\n        vec3  ns = n_ * D.wyz - D.xzx;\n    \n        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n        vec4 x_ = floor(j * ns.z);\n        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n        vec4 x = x_ *ns.x + ns.yyyy;\n        vec4 y = y_ *ns.x + ns.yyyy;\n        vec4 h = 1.0 - abs(x) - abs(y);\n    \n        vec4 b0 = vec4( x.xy, y.xy );\n        vec4 b1 = vec4( x.zw, y.zw );\n    \n        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n        vec4 s0 = floor(b0)*2.0 + 1.0;\n        vec4 s1 = floor(b1)*2.0 + 1.0;\n        vec4 sh = -step(h, vec4(0.0));\n    \n        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n        vec3 p0 = vec3(a0.xy,h.x);\n        vec3 p1 = vec3(a0.zw,h.y);\n        vec3 p2 = vec3(a1.xy,h.z);\n        vec3 p3 = vec3(a1.zw,h.w);\n    \n        //Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n    \n        // Mix final noise value\n        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n        m = m * m;\n        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n    }\n    \n    float snoise(in vec4 v) {\n        const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                            0.276393202250021,  // 2 * G4\n                            0.414589803375032,  // 3 * G4\n                            -0.447213595499958); // -1 + 4 * G4\n    \n        // First corner\n        vec4 i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n        vec4 x0 = v -   i + dot(i, C.xxxx);\n    \n        // Other corners\n    \n        // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n        vec4 i0;\n        vec3 isX = step( x0.yzw, x0.xxx );\n        vec3 isYZ = step( x0.zww, x0.yyz );\n        //  i0.x = dot( isX, vec3( 1.0 ) );\n        i0.x = isX.x + isX.y + isX.z;\n        i0.yzw = 1.0 - isX;\n        //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n        i0.y += isYZ.x + isYZ.y;\n        i0.zw += 1.0 - isYZ.xy;\n        i0.z += isYZ.z;\n        i0.w += 1.0 - isYZ.z;\n    \n        // i0 now contains the unique values 0,1,2,3 in each channel\n        vec4 i3 = clamp( i0, 0.0, 1.0 );\n        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n    \n        //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n        //  x1 = x0 - i1  + 1.0 * C.xxxx\n        //  x2 = x0 - i2  + 2.0 * C.xxxx\n        //  x3 = x0 - i3  + 3.0 * C.xxxx\n        //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n        vec4 x1 = x0 - i1 + C.xxxx;\n        vec4 x2 = x0 - i2 + C.yyyy;\n        vec4 x3 = x0 - i3 + C.zzzz;\n        vec4 x4 = x0 + C.wwww;\n    \n        // Permutations\n        i = mod289(i);\n        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n        vec4 j1 = permute( permute( permute( permute (\n                    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    \n        // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n        // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n    \n        vec4 p0 = grad4(j0,   ip);\n        vec4 p1 = grad4(j1.x, ip);\n        vec4 p2 = grad4(j1.y, ip);\n        vec4 p3 = grad4(j1.z, ip);\n        vec4 p4 = grad4(j1.w, ip);\n    \n        // Normalise gradients\n        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n        p0 *= norm.x;\n        p1 *= norm.y;\n        p2 *= norm.z;\n        p3 *= norm.w;\n        p4 *= taylorInvSqrt(dot(p4,p4));\n    \n        // Mix contributions from the five corners\n        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n        m0 = m0 * m0;\n        m1 = m1 * m1;\n        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                    + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n    }\n    \n    vec3 snoise3( vec3 x ){\n        float s  = snoise(vec3( x ));\n        float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n        float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    vec3 snoise3( vec4 x ){\n        float s  = snoise(vec4( x ));\n        float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n        float s2 = snoise(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n        vec3 c = vec3( s , s1 , s2 );\n        return c;\n    }\n    \n    #endif\n    \n    \n    void main() {\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        st = ratio(st, u_resolution);\n        vec3 color = vec3(0.);\n    \n        float grid = u_resolution.x/50.;\n        vec2 st_i = floor(st * grid)/grid;\n    \n        float n = 0.4 + snoise(vec3(st_i, u_time)) * 0.8;\n          \n        color += hsv2rgb(vec3(n * .41, 1., 1.));\n    \n        gl_FragColor = vec4(color,1.0);\n    }\n    "
  },
  sun: {
    fragmentShader: "#ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    \n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse; \n    uniform float u_time;\n    \n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_STROKE\n    #define FNC_STROKE\n    \n    float stroke(float x, float s, float w) {\n        float d= step(s, x+w*.5) - step(s, x-w*.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_CIRCLESDF\n    #define FNC_CIRCLESDF\n    \n    float circleSDF(vec2 st) {\n    \n        return length(st-.5)*2.;\n    \n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_FILL\n    #define FNC_FILL\n    \n    float fill(float x, float size) {\n        return 1.-step(size, x);\n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_TRISDF\n    #define FNC_TRISDF\n    \n    float triSDF(vec2 st) {\n    \n        st = (st*2.-1.)*2.;\n        return max(abs(st.x) * 0.866025 +st.y * 0.5, -st.y * 0.5);\n    \n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_ROTATE\n    #define FNC_ROTATE\n    \n    vec2 rotate(vec2 st, float a) {\n        st = mat2(cos(a), -sin(a),\n                    sin(a), cos(a))*(st-.5);\n        return st+.5;\n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_POLYSDF\n    #define FNC_POLYSDF\n    \n    #ifndef PI\n    #define PI 3.1415926535897932384626433832795\n    #endif\n    \n    #ifndef TAU\n    #define TAU 6.2831853071795864769252867665590\n    #endif\n    \n    float polySDF(vec2 st, int V) {\n    \n        st = st*2.-1.;\n        float a = atan(st.x, st.y)+PI;\n        float r = length(st);\n        float v = TAU/float(V);\n        return cos(floor(.5+a/v)*v-a)*r;\n    \n    }\n    \n    #endif\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    #ifndef FNC_STARSDF\n    #define FNC_STARSDF\n    \n    #ifndef PI\n    #define PI 3.1415926535897932384626433832795\n    #endif\n    \n    #ifndef TAU\n    #define TAU 6.2831853071795864769252867665590\n    #endif\n    \n    float starSDF(vec2 st, int V, float s) {\n    \n        st = st*4.-2.;\n        float a = atan(st.y, st.x)/TAU;\n        float seg = a * float(V);\n        a = ((floor(seg) + .5)/float(V) + \n            mix(s, -s, step(.5, fract(seg))))\n            * TAU;\n        return abs(dot(vec2(cos(a), sin(a)), \n            st));\n    \n    }\n    \n    #endif\n    \n    #ifndef FNC_RATIO\n    #define FNC_RATIO\n    vec2 ratio(in vec2 st, in vec2 s) {\n        return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                    vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                    step(s.x,s.y));\n    }\n    #endif\n    \n    \n    void main() {\n        float QRT_PI = PI/4.;\n        vec2 st = gl_FragCoord.xy/u_resolution.xy;\n        st = ratio(st, u_resolution);\n        vec3 color = vec3(0.);\n    \n        st = st*1.5;\n        st = st-.25;\n    \n        float bg = starSDF(st, 16, .1);\n        color += fill(bg, 1.3);\n        float l = 0.;\n        for (float i = 0.; i < 8.; i++) {\n            vec2 xy = rotate(st, QRT_PI*i);\n            xy.y -= .3;\n            float tri = polySDF(xy, 3);\n            color += fill(tri, .3);\n            l += stroke(tri, .3, .03);\n        }\n        color *= 1.-l;\n        float c = polySDF(st, 8);\n        color -= stroke(c, .15, .04);\n    \n        gl_FragColor = vec4(color,1.0);\n    }"
  }
};
var p5 = {
  sea: {
    setup: function setup(p5, canvasParentRef) {
      p5.createCanvas(canvasParentRef.clientWidth, 500, p5.WEBGL).parent(canvasParentRef);
    },
    windowResized: function windowResized(p5) {
      p5.resizeCanvas(p5["canvas"].parentElement.clientWidth, 500);
    },
    draw: function draw(p5) {
      p5.background(1050);
      p5.strokeWeight(3);
      p5.translate(800, 200, -90);
      p5.rotateY(-90);

      for (var i = 0; i < 15; i++) {
        p5.push();

        for (var j = 0; j < 15; j++) {
          if (j < i) continue;
          p5.push();
          p5.translate(i * 75, 0, j * 75);
          p5.box(70, Math.sin(p5.frameCount * 0.02 + j * 0.5 + i * 0.5) * 60 + 90, 70);
          p5.pop();
        }

        p5.pop();
      }
    }
  }
};
var aboutPageContent = {
  text: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: ["This site was made by me, ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
        href: "https://www.linkedin.com/in/francesco-arillotta-104aa8122/",
        children: "Francesco Arillotta."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 1686,
        columnNumber: 33
      }, undefined), " Think of it as a fun weekend project to know me - a sort of expressive experiment through the weird crap I do."]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 1685,
      columnNumber: 5
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "I used a mix of technologies that I am very passionate about. Among those technologies are: Next.js, React, Typescript, GLSL, Three.js, P5.js, Framer/motion."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1688,
      columnNumber: 5
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1691,
      columnNumber: 5
    }, undefined)]
  }, void 0, true)
};
var roles = [{
  company: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
    href: "https://www.ynap.com/",
    children: "Yoox Net-a-Porter"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1700,
    columnNumber: 14
  }, undefined),
  title: "Frontend Developer",
  location: "Bologna, Italy",
  date: "May 2021 - Present",
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1705,
      columnNumber: 7
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1708,
      columnNumber: 7
    }, undefined)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 1704,
    columnNumber: 15
  }, undefined),
  shader: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__.Shader, {
    shader: shaders.fullscreenFbm
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1712,
    columnNumber: 13
  }, undefined)
}, {
  company: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
    href: "https://www.sovrn.com/",
    children: "Sovrn"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1714,
    columnNumber: 14
  }, undefined),
  title: "Fullstack Software Engineer",
  location: "London, United Kingdom",
  date: "July 2020 - April 2021",
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1719,
      columnNumber: 7
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1722,
      columnNumber: 7
    }, undefined)]
  }, void 0, true),
  shader: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__.Shader, {
    shader: shaders.sun
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1726,
    columnNumber: 13
  }, undefined)
}, {
  company: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
    href: "https://www.sovrn.com/",
    children: "Sovrn"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1728,
    columnNumber: 14
  }, undefined),
  title: "Implementation Engineer II, Market Dev",
  location: "London, United Kingdom",
  date: "January 2020 - June 2020",
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1733,
      columnNumber: 7
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1736,
      columnNumber: 7
    }, undefined)]
  }, void 0, true),
  shader: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__.Shader, {
    shader: shaders.ditherTexture
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1740,
    columnNumber: 13
  }, undefined)
}, {
  company: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
    href: "https://www.sovrn.com/",
    children: "Sovrn"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1742,
    columnNumber: 14
  }, undefined),
  title: "Solutions Engineer",
  location: "London, United Kingdom",
  date: "May 2019 - December 2019",
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1747,
      columnNumber: 7
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1750,
      columnNumber: 7
    }, undefined)]
  }, void 0, true),
  shader: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__.Shader, {
    shader: shaders.simplexNoise
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1754,
    columnNumber: 13
  }, undefined)
}, {
  company: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Anchor_Anchor__WEBPACK_IMPORTED_MODULE_1__.Anchor, {
    href: "https://www.sovrn.com/",
    children: "Sovrn"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1756,
    columnNumber: 14
  }, undefined),
  title: "Operations Specialist",
  location: "London, United Kingdom",
  date: "August 2018 - May 2019",
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1761,
      columnNumber: 7
    }, undefined), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("p", {
      children: "and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 1764,
      columnNumber: 7
    }, undefined)]
  }, void 0, true),
  shader: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Shader_Shader__WEBPACK_IMPORTED_MODULE_2__.Shader, {
    shader: shaders.raymarching
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1768,
    columnNumber: 13
  }, undefined)
}];
var terms = ["writing code", "listening to music", "watching a film", "possibly sleeping"];

var homepageText = /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
  children: ["Hi, I'm Fran. As you read this, I am ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_TextCarousel_TextCarousel__WEBPACK_IMPORTED_MODULE_3__.TextCarousel, {
    terms: terms,
    color: "hsl(212deg 90% 64%)"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1774,
    columnNumber: 61
  }, undefined), " in ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("del", {
    children: "London"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 1774,
    columnNumber: 124
  }, undefined), " Bologna, Italy."]
}, void 0, true);



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29uc3RhbnRzLnRzeCJdLCJuYW1lcyI6WyJzaGFkZXJzIiwiZnVsbHNjcmVlbkZibSIsImZyYWdtZW50U2hhZGVyIiwicmF5bWFyY2hpbmciLCJmYm0iLCJ0ZW1wbGF0ZSIsImRpdGhlclRleHR1cmUiLCJ0ZXh0dXJlIiwic2ltcGxleE5vaXNlIiwic3VuIiwicDUiLCJzZWEiLCJzZXR1cCIsImNhbnZhc1BhcmVudFJlZiIsImNyZWF0ZUNhbnZhcyIsImNsaWVudFdpZHRoIiwiV0VCR0wiLCJwYXJlbnQiLCJ3aW5kb3dSZXNpemVkIiwicmVzaXplQ2FudmFzIiwicGFyZW50RWxlbWVudCIsImRyYXciLCJiYWNrZ3JvdW5kIiwic3Ryb2tlV2VpZ2h0IiwidHJhbnNsYXRlIiwicm90YXRlWSIsImkiLCJwdXNoIiwiaiIsImJveCIsIk1hdGgiLCJzaW4iLCJmcmFtZUNvdW50IiwicG9wIiwiYWJvdXRQYWdlQ29udGVudCIsInRleHQiLCJyb2xlcyIsImNvbXBhbnkiLCJ0aXRsZSIsImxvY2F0aW9uIiwiZGF0ZSIsImNoaWxkcmVuIiwic2hhZGVyIiwidGVybXMiLCJob21lcGFnZVRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQU1BLE9BQU8sR0FBRztBQUNkQyxlQUFhLEVBQUU7QUFDYkMsa0JBQWM7QUFERCxHQUREO0FBNFhkQyxhQUFXLEVBQUU7QUFDWEQsa0JBQWM7QUFESCxHQTVYQztBQThrQmRFLEtBQUcsRUFBRTtBQUNIRixrQkFBYztBQURYLEdBOWtCUztBQXk4QmRHLFVBQVEsRUFBRTtBQUNSSCxrQkFBYztBQUROLEdBejhCSTtBQTQ5QmRJLGVBQWEsRUFBRTtBQUNiSixrQkFBYywwOUlBREQ7QUF1SWJLLFdBQU8sRUFBRTtBQXZJSSxHQTU5QkQ7QUFxbUNkQyxjQUFZLEVBQUU7QUFDWk4sa0JBQWM7QUFERixHQXJtQ0E7QUFnOENkTyxLQUFHLEVBQUU7QUFDSFAsa0JBQWM7QUFEWDtBQWg4Q1MsQ0FBaEI7QUE0bURBLElBQU1RLEVBQTJCLEdBQUc7QUFDbENDLEtBQUcsRUFBRTtBQUNIQyxTQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFnQkYsRUFBaEIsRUFBb0JHLGVBQXBCLEVBQXFDO0FBQzFDSCxRQUFFLENBQUNJLFlBQUgsQ0FBZ0JELGVBQWUsQ0FBQ0UsV0FBaEMsRUFBNkMsR0FBN0MsRUFBa0RMLEVBQUUsQ0FBQ00sS0FBckQsRUFBNERDLE1BQTVELENBQW1FSixlQUFuRTtBQUNELEtBSEU7QUFJSEssaUJBQWEsRUFBRSxTQUFTQSxhQUFULENBQXdCUixFQUF4QixFQUE0QjtBQUN6Q0EsUUFBRSxDQUFDUyxZQUFILENBQWdCVCxFQUFFLENBQUMsUUFBRCxDQUFGLENBQWFVLGFBQWIsQ0FBMkJMLFdBQTNDLEVBQXdELEdBQXhEO0FBQ0QsS0FORTtBQU9ITSxRQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFlWCxFQUFmLEVBQW1CO0FBQ3ZCQSxRQUFFLENBQUNZLFVBQUgsQ0FBYyxJQUFkO0FBQ0FaLFFBQUUsQ0FBQ2EsWUFBSCxDQUFnQixDQUFoQjtBQUVBYixRQUFFLENBQUNjLFNBQUgsQ0FBYSxHQUFiLEVBQWtCLEdBQWxCLEVBQXVCLENBQUMsRUFBeEI7QUFFQWQsUUFBRSxDQUFDZSxPQUFILENBQVcsQ0FBQyxFQUFaOztBQUVBLFdBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QixFQUE2QjtBQUN6QmhCLFVBQUUsQ0FBQ2lCLElBQUg7O0FBQ0YsYUFBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO0FBQzNCLGNBQUlBLENBQUMsR0FBR0YsQ0FBUixFQUFXO0FBQ1hoQixZQUFFLENBQUNpQixJQUFIO0FBQ0FqQixZQUFFLENBQUNjLFNBQUgsQ0FBYUUsQ0FBQyxHQUFHLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCRSxDQUFDLEdBQUcsRUFBNUI7QUFDQWxCLFlBQUUsQ0FBQ21CLEdBQUgsQ0FBTyxFQUFQLEVBQVdDLElBQUksQ0FBQ0MsR0FBTCxDQUFTckIsRUFBRSxDQUFDc0IsVUFBSCxHQUFnQixJQUFoQixHQUF1QkosQ0FBQyxHQUFDLEdBQXpCLEdBQStCRixDQUFDLEdBQUMsR0FBMUMsSUFBa0QsRUFBbEQsR0FBdUQsRUFBbEUsRUFBc0UsRUFBdEU7QUFDQWhCLFlBQUUsQ0FBQ3VCLEdBQUg7QUFDRDs7QUFDRHZCLFVBQUUsQ0FBQ3VCLEdBQUg7QUFFRDtBQUNGO0FBM0JFO0FBRDZCLENBQXBDO0FBZ0NBLElBQU1DLGdCQUFnQixHQUFHO0FBRXZCQyxNQUFJLGVBQUU7QUFBQSw0QkFDSjtBQUFBLDREQUM0Qiw4REFBQyw2REFBRDtBQUFRLFlBQUksRUFBRSw0REFBZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFENUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQURJLGVBSUo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBSkksZUFPSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFQSTtBQUFBO0FBRmlCLENBQXpCO0FBZ0JBLElBQU1DLEtBQWMsR0FBRyxDQUNyQjtBQUNFQyxTQUFPLGVBQUUsOERBQUMsNkRBQUQ7QUFBUSxRQUFJLEVBQUUsdUJBQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFEWDtBQUVFQyxPQUFLLEVBQUUsb0JBRlQ7QUFHRUMsVUFBUSxFQUFFLGdCQUhaO0FBSUVDLE1BQUksRUFBRSxvQkFKUjtBQUtFQyxVQUFRLGVBQUU7QUFBQSw0QkFDUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFEUSxlQUlSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUpRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUxaO0FBYUVDLFFBQU0sZUFBRSw4REFBQyw2REFBRDtBQUFRLFVBQU0sRUFBRTFDLE9BQU8sQ0FBQ0M7QUFBeEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWJWLENBRHFCLEVBZWxCO0FBQ0RvQyxTQUFPLGVBQUUsOERBQUMsNkRBQUQ7QUFBUSxRQUFJLEVBQUUsd0JBQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFEUjtBQUVEQyxPQUFLLEVBQUUsNkJBRk47QUFHREMsVUFBUSxFQUFFLHdCQUhUO0FBSURDLE1BQUksRUFBRSx3QkFKTDtBQUtEQyxVQUFRLGVBQUU7QUFBQSw0QkFDUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFEUSxlQUlSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUpRO0FBQUEsa0JBTFQ7QUFhREMsUUFBTSxlQUFFLDhEQUFDLDZEQUFEO0FBQVEsVUFBTSxFQUFFMUMsT0FBTyxDQUFDUztBQUF4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYlAsQ0Fma0IsRUE2QmxCO0FBQ0Q0QixTQUFPLGVBQUUsOERBQUMsNkRBQUQ7QUFBUSxRQUFJLEVBQUUsd0JBQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFEUjtBQUVEQyxPQUFLLEVBQUUsd0NBRk47QUFHREMsVUFBUSxFQUFFLHdCQUhUO0FBSURDLE1BQUksRUFBRSwwQkFKTDtBQUtEQyxVQUFRLGVBQUU7QUFBQSw0QkFDUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFEUSxlQUlSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUpRO0FBQUEsa0JBTFQ7QUFhREMsUUFBTSxlQUFFLDhEQUFDLDZEQUFEO0FBQVEsVUFBTSxFQUFFMUMsT0FBTyxDQUFDTTtBQUF4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYlAsQ0E3QmtCLEVBMkNsQjtBQUNEK0IsU0FBTyxlQUFFLDhEQUFDLDZEQUFEO0FBQVEsUUFBSSxFQUFFLHdCQUFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBRFI7QUFFREMsT0FBSyxFQUFFLG9CQUZOO0FBR0RDLFVBQVEsRUFBRSx3QkFIVDtBQUlEQyxNQUFJLEVBQUUsMEJBSkw7QUFLREMsVUFBUSxlQUFFO0FBQUEsNEJBQ1I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBRFEsZUFJUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFKUTtBQUFBLGtCQUxUO0FBYURDLFFBQU0sZUFBRSw4REFBQyw2REFBRDtBQUFRLFVBQU0sRUFBRTFDLE9BQU8sQ0FBQ1E7QUFBeEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWJQLENBM0NrQixFQXlEbEI7QUFDRDZCLFNBQU8sZUFBRSw4REFBQyw2REFBRDtBQUFRLFFBQUksRUFBRSx3QkFBZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURSO0FBRURDLE9BQUssRUFBRSx1QkFGTjtBQUdEQyxVQUFRLEVBQUUsd0JBSFQ7QUFJREMsTUFBSSxFQUFFLHdCQUpMO0FBS0RDLFVBQVEsZUFBRTtBQUFBLDRCQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQURRLGVBSVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBSlE7QUFBQSxrQkFMVDtBQWFEQyxRQUFNLGVBQUUsOERBQUMsNkRBQUQ7QUFBUSxVQUFNLEVBQUUxQyxPQUFPLENBQUNHO0FBQXhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFiUCxDQXpEa0IsQ0FBdkI7QUEwRUEsSUFBTXdDLEtBQUssR0FBRyxDQUFDLGNBQUQsRUFBaUIsb0JBQWpCLEVBQXVDLGlCQUF2QyxFQUEwRCxtQkFBMUQsQ0FBZDs7QUFFQSxJQUFNQyxZQUFZLGdCQUFHO0FBQUEsbUVBQXVDLDhEQUFDLCtFQUFEO0FBQWMsU0FBSyxFQUFFRCxLQUFyQjtBQUE0QixTQUFLLEVBQUU7QUFBbkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUF2Qyx1QkFBc0c7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBdEc7QUFBQSxnQkFBckI7O0FBRUEiLCJmaWxlIjoic3RhdGljL3dlYnBhY2svcGFnZXMvd29yay43ODFiYjQxMmQxNzljYmY4MzBjZS5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQNVByb3BzLCBSb2xlc30gZnJvbSBcIi4vdHlwZXNcIjtcclxuaW1wb3J0IHtBbmNob3J9IGZyb20gXCIuL2NvbXBvbmVudHMvQW5jaG9yL0FuY2hvclwiO1xyXG5pbXBvcnQge1NoYWRlcn0gZnJvbSBcIi4vY29tcG9uZW50cy9TaGFkZXIvU2hhZGVyXCI7XHJcbmltcG9ydCB7VGV4dENhcm91c2VsfSBmcm9tIFwiLi9jb21wb25lbnRzL1RleHRDYXJvdXNlbC9UZXh0Q2Fyb3VzZWxcIjtcclxuXHJcbmNvbnN0IHNoYWRlcnMgPSB7XHJcbiAgZnVsbHNjcmVlbkZibToge1xyXG4gICAgZnJhZ21lbnRTaGFkZXI6IGAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZuZGVmIEZOQ19NT0QyODlcclxuICAgICNkZWZpbmUgRk5DX01PRDI4OVxyXG4gICAgZmxvYXQgbW9kMjg5KGluIGZsb2F0IHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMiBtb2QyODkoaW4gdmVjMiB4KSB7XHJcbiAgICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzMgbW9kMjg5KGluIHZlYzMgeCkge1xyXG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IG1vZDI4OShpbiB2ZWM0IHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgI2lmbmRlZiBGTkNfUEVSTVVURVxyXG4gICAgI2RlZmluZSBGTkNfUEVSTVVURVxyXG4gICAgZmxvYXQgcGVybXV0ZShpbiBmbG9hdCB4KSB7XHJcbiAgICAgICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuKSArIDEuKSp4KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBwZXJtdXRlKGluIHZlYzMgeCkge1xyXG4gICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IHBlcm11dGUoaW4gdmVjNCB4KSB7XHJcbiAgICAgICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuKSArIDEuKSp4KTtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19UQVlMT1JJTlZTUVJUXHJcbiAgICAjZGVmaW5lIEZOQ19UQVlMT1JJTlZTUVJUXHJcbiAgICBmbG9hdCB0YXlsb3JJbnZTcXJ0KGluIGZsb2F0IHIpIHtcclxuICAgICAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjNCB0YXlsb3JJbnZTcXJ0KGluIHZlYzQgcikge1xyXG4gICAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZuZGVmIEZOQ19HUkFENFxyXG4gICAgI2RlZmluZSBGTkNfR1JBRDRcclxuICAgIHZlYzQgZ3JhZDQoZmxvYXQgaiwgdmVjNCBpcCkge1xyXG4gICAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgLTEuMCk7XHJcbiAgICAgICAgdmVjNCBwLHM7XHJcbiAgICBcclxuICAgICAgICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcclxuICAgICAgICBwLncgPSAxLjUgLSBkb3QoYWJzKHAueHl6KSwgb25lcy54eXopO1xyXG4gICAgICAgIHMgPSB2ZWM0KGxlc3NUaGFuKHAsIHZlYzQoMC4wKSkpO1xyXG4gICAgICAgIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgYXV0aG9yOiBbSWFuIE1jRXdhbiwgQXNoaW1hIEFydHNdXHJcbiAgICBkZXNjcmlwdGlvbjogU2ltcGxleCBOb2lzZSBodHRwczovL2dpdGh1Yi5jb20vYXNoaW1hL3dlYmdsLW5vaXNlXHJcbiAgICB1c2U6IHNub2lzZSg8dmVjMnx2ZWMzfHZlYzQ+IHBvcylcclxuICAgIGxpY2Vuc2U6IHxcclxuICAgICAgQ29weXJpZ2h0IChDKSAyMDExIEFzaGltYSBBcnRzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICBDb3B5cmlnaHQgKEMpIDIwMTEtMjAxNiBieSBTdGVmYW4gR3VzdGF2c29uIChDbGFzc2ljIG5vaXNlIGFuZCBvdGhlcnMpXHJcbiAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICAgICAgUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICAgICBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAgICAgIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIEdQVUltYWdlIGZyYW1ld29yayBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICBcclxuICAgICovXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1NOT0lTRVxyXG4gICAgI2RlZmluZSBGTkNfU05PSVNFXHJcbiAgICBmbG9hdCBzbm9pc2UoaW4gdmVjMiB2KSB7XHJcbiAgICAgICAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgIC8vICgzLjAtc3FydCgzLjApKS82LjBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMzY2MDI1NDAzNzg0NDM5LCAgLy8gMC41KihzcXJ0KDMuMCktMS4wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAgLy8gLTEuMCArIDIuMCAqIEMueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wMjQzOTAyNDM5MDI0MzkpOyAvLyAxLjAgLyA0MS4wXHJcbiAgICAgICAgLy8gRmlyc3QgY29ybmVyXHJcbiAgICAgICAgdmVjMiBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkgKTtcclxuICAgICAgICB2ZWMyIHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4KTtcclxuICAgIFxyXG4gICAgICAgIC8vIE90aGVyIGNvcm5lcnNcclxuICAgICAgICB2ZWMyIGkxO1xyXG4gICAgICAgIC8vaTEueCA9IHN0ZXAoIHgwLnksIHgwLnggKTsgLy8geDAueCA+IHgwLnkgPyAxLjAgOiAwLjBcclxuICAgICAgICAvL2kxLnkgPSAxLjAgLSBpMS54O1xyXG4gICAgICAgIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XHJcbiAgICAgICAgLy8geDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHggO1xyXG4gICAgICAgIC8vIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHggO1xyXG4gICAgICAgIC8vIHgyID0geDAgLSAxLjAgKyAyLjAgKiBDLnh4IDtcclxuICAgICAgICB2ZWM0IHgxMiA9IHgwLnh5eHkgKyBDLnh4eno7XHJcbiAgICAgICAgeDEyLnh5IC09IGkxO1xyXG4gICAgXHJcbiAgICAgICAgLy8gUGVybXV0YXRpb25zXHJcbiAgICAgICAgaSA9IG1vZDI4OShpKTsgLy8gQXZvaWQgdHJ1bmNhdGlvbiBlZmZlY3RzIGluIHBlcm11dGF0aW9uXHJcbiAgICAgICAgdmVjMyBwID0gcGVybXV0ZSggcGVybXV0ZSggaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCApKVxyXG4gICAgICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCApKTtcclxuICAgIFxyXG4gICAgICAgIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSwgZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcclxuICAgICAgICBtID0gbSptIDtcclxuICAgICAgICBtID0gbSptIDtcclxuICAgIFxyXG4gICAgICAgIC8vIEdyYWRpZW50czogNDEgcG9pbnRzIHVuaWZvcm1seSBvdmVyIGEgbGluZSwgbWFwcGVkIG9udG8gYSBkaWFtb25kLlxyXG4gICAgICAgIC8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0MSAoNDEqNyA9IDI4NylcclxuICAgIFxyXG4gICAgICAgIHZlYzMgeCA9IDIuMCAqIGZyYWN0KHAgKiBDLnd3dykgLSAxLjA7XHJcbiAgICAgICAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xyXG4gICAgICAgIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcclxuICAgICAgICB2ZWMzIGEwID0geCAtIG94O1xyXG4gICAgXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxyXG4gICAgICAgIC8vIEFwcHJveGltYXRpb24gb2Y6IG0gKj0gaW52ZXJzZXNxcnQoIGEwKmEwICsgaCpoICk7XHJcbiAgICAgICAgbSAqPSAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqICggYTAqYTAgKyBoKmggKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENvbXB1dGUgZmluYWwgbm9pc2UgdmFsdWUgYXQgUFxyXG4gICAgICAgIHZlYzMgZztcclxuICAgICAgICBnLnggID0gYTAueCAgKiB4MC54ICArIGgueCAgKiB4MC55O1xyXG4gICAgICAgIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XHJcbiAgICAgICAgcmV0dXJuIDEzMC4wICogZG90KG0sIGcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIGZsb2F0IHNub2lzZShpbiB2ZWMzIHYpIHtcclxuICAgICAgICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XHJcbiAgICAgICAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEZpcnN0IGNvcm5lclxyXG4gICAgICAgIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSApO1xyXG4gICAgICAgIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XHJcbiAgICBcclxuICAgICAgICAvLyBPdGhlciBjb3JuZXJzXHJcbiAgICAgICAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XHJcbiAgICAgICAgdmVjMyBsID0gMS4wIC0gZztcclxuICAgICAgICB2ZWMzIGkxID0gbWluKCBnLnh5eiwgbC56eHkgKTtcclxuICAgICAgICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcclxuICAgIFxyXG4gICAgICAgIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xyXG4gICAgICAgIC8vICAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4O1xyXG4gICAgICAgIC8vICAgeDIgPSB4MCAtIGkyICArIDIuMCAqIEMueHh4O1xyXG4gICAgICAgIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xyXG4gICAgICAgIHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XHJcbiAgICAgICAgdmVjMyB4MiA9IHgwIC0gaTIgKyBDLnl5eTsgLy8gMi4wKkMueCA9IDEvMyA9IEMueVxyXG4gICAgICAgIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XHJcbiAgICBcclxuICAgICAgICAvLyBQZXJtdXRhdGlvbnNcclxuICAgICAgICBpID0gbW9kMjg5KGkpO1xyXG4gICAgICAgIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXHJcbiAgICAgICAgICAgICAgICAgICAgaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnkgKyB2ZWM0KDAuMCwgaTEueSwgaTIueSwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XHJcbiAgICBcclxuICAgICAgICAvLyBHcmFkaWVudHM6IDd4NyBwb2ludHMgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi5cclxuICAgICAgICAvLyBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGUgb2YgNDkgKDQ5KjYgPSAyOTQpXHJcbiAgICAgICAgZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxyXG4gICAgICAgIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqIG5zLnopOyAgLy8gIG1vZChwLDcqNylcclxuICAgIFxyXG4gICAgICAgIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XHJcbiAgICAgICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxyXG4gICAgXHJcbiAgICAgICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xyXG4gICAgICAgIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcclxuICAgICAgICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XHJcbiAgICBcclxuICAgICAgICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xyXG4gICAgICAgIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XHJcbiAgICBcclxuICAgICAgICAvL3ZlYzQgczAgPSB2ZWM0KGxlc3NUaGFuKGIwLDAuMCkpKjIuMCAtIDEuMDtcclxuICAgICAgICAvL3ZlYzQgczEgPSB2ZWM0KGxlc3NUaGFuKGIxLDAuMCkpKjIuMCAtIDEuMDtcclxuICAgICAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcclxuICAgICAgICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcclxuICAgICAgICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcclxuICAgIFxyXG4gICAgICAgIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcclxuICAgICAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XHJcbiAgICBcclxuICAgICAgICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xyXG4gICAgICAgIHZlYzMgcDEgPSB2ZWMzKGEwLnp3LGgueSk7XHJcbiAgICAgICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcclxuICAgICAgICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xyXG4gICAgXHJcbiAgICAgICAgLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXHJcbiAgICAgICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XHJcbiAgICAgICAgcDAgKj0gbm9ybS54O1xyXG4gICAgICAgIHAxICo9IG5vcm0ueTtcclxuICAgICAgICBwMiAqPSBub3JtLno7XHJcbiAgICAgICAgcDMgKj0gbm9ybS53O1xyXG4gICAgXHJcbiAgICAgICAgLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXHJcbiAgICAgICAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XHJcbiAgICAgICAgbSA9IG0gKiBtO1xyXG4gICAgICAgIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmbG9hdCBzbm9pc2UoaW4gdmVjNCB2KSB7XHJcbiAgICAgICAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMjc2MzkzMjAyMjUwMDIxLCAgLy8gMiAqIEc0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjQxNDU4OTgwMzM3NTAzMiwgIC8vIDMgKiBHNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLTAuNDQ3MjEzNTk1NDk5OTU4KTsgLy8gLTEgKyA0ICogRzRcclxuICAgIFxyXG4gICAgICAgIC8vIEZpcnN0IGNvcm5lclxyXG4gICAgICAgIHZlYzQgaSAgPSBmbG9vcih2ICsgZG90KHYsIHZlYzQoLjMwOTAxNjk5NDM3NDk0NzQ1MSkpICk7IC8vIChzcXJ0KDUpIC0gMSkvNFxyXG4gICAgICAgIHZlYzQgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHh4eCk7XHJcbiAgICBcclxuICAgICAgICAvLyBPdGhlciBjb3JuZXJzXHJcbiAgICBcclxuICAgICAgICAvLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxyXG4gICAgICAgIHZlYzQgaTA7XHJcbiAgICAgICAgdmVjMyBpc1ggPSBzdGVwKCB4MC55encsIHgwLnh4eCApO1xyXG4gICAgICAgIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XHJcbiAgICAgICAgLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcclxuICAgICAgICBpMC54ID0gaXNYLnggKyBpc1gueSArIGlzWC56O1xyXG4gICAgICAgIGkwLnl6dyA9IDEuMCAtIGlzWDtcclxuICAgICAgICAvLyAgaTAueSArPSBkb3QoIGlzWVoueHksIHZlYzIoIDEuMCApICk7XHJcbiAgICAgICAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XHJcbiAgICAgICAgaTAuencgKz0gMS4wIC0gaXNZWi54eTtcclxuICAgICAgICBpMC56ICs9IGlzWVouejtcclxuICAgICAgICBpMC53ICs9IDEuMCAtIGlzWVouejtcclxuICAgIFxyXG4gICAgICAgIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxyXG4gICAgICAgIHZlYzQgaTMgPSBjbGFtcCggaTAsIDAuMCwgMS4wICk7XHJcbiAgICAgICAgdmVjNCBpMiA9IGNsYW1wKCBpMC0xLjAsIDAuMCwgMS4wICk7XHJcbiAgICAgICAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XHJcbiAgICBcclxuICAgICAgICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxyXG4gICAgICAgIC8vICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHh4XHJcbiAgICAgICAgLy8gIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxyXG4gICAgICAgIC8vICB4NCA9IHgwIC0gMS4wICsgNC4wICogQy54eHh4XHJcbiAgICAgICAgdmVjNCB4MSA9IHgwIC0gaTEgKyBDLnh4eHg7XHJcbiAgICAgICAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XHJcbiAgICAgICAgdmVjNCB4MyA9IHgwIC0gaTMgKyBDLnp6eno7XHJcbiAgICAgICAgdmVjNCB4NCA9IHgwICsgQy53d3d3O1xyXG4gICAgXHJcbiAgICAgICAgLy8gUGVybXV0YXRpb25zXHJcbiAgICAgICAgaSA9IG1vZDI4OShpKTtcclxuICAgICAgICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcclxuICAgICAgICB2ZWM0IGoxID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSAoXHJcbiAgICAgICAgICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XHJcbiAgICBcclxuICAgICAgICAvLyBHcmFkaWVudHM6IDd4N3g2IHBvaW50cyBvdmVyIGEgY3ViZSwgbWFwcGVkIG9udG8gYSA0LWNyb3NzIHBvbHl0b3BlXHJcbiAgICAgICAgLy8gNyo3KjYgPSAyOTQsIHdoaWNoIGlzIGNsb3NlIHRvIHRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkuXHJcbiAgICAgICAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XHJcbiAgICBcclxuICAgICAgICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xyXG4gICAgICAgIHZlYzQgcDEgPSBncmFkNChqMS54LCBpcCk7XHJcbiAgICAgICAgdmVjNCBwMiA9IGdyYWQ0KGoxLnksIGlwKTtcclxuICAgICAgICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xyXG4gICAgICAgIHZlYzQgcDQgPSBncmFkNChqMS53LCBpcCk7XHJcbiAgICBcclxuICAgICAgICAvLyBOb3JtYWxpc2UgZ3JhZGllbnRzXHJcbiAgICAgICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XHJcbiAgICAgICAgcDAgKj0gbm9ybS54O1xyXG4gICAgICAgIHAxICo9IG5vcm0ueTtcclxuICAgICAgICBwMiAqPSBub3JtLno7XHJcbiAgICAgICAgcDMgKj0gbm9ybS53O1xyXG4gICAgICAgIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XHJcbiAgICBcclxuICAgICAgICAvLyBNaXggY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcclxuICAgICAgICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XHJcbiAgICAgICAgdmVjMiBtMSA9IG1heCgwLjYgLSB2ZWMyKGRvdCh4Myx4MyksIGRvdCh4NCx4NCkgICAgICAgICAgICApLCAwLjApO1xyXG4gICAgICAgIG0wID0gbTAgKiBtMDtcclxuICAgICAgICBtMSA9IG0xICogbTE7XHJcbiAgICAgICAgcmV0dXJuIDQ5LjAgKiAoIGRvdChtMCptMCwgdmVjMyggZG90KCBwMCwgeDAgKSwgZG90KCBwMSwgeDEgKSwgZG90KCBwMiwgeDIgKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgKyBkb3QobTEqbTEsIHZlYzIoIGRvdCggcDMsIHgzICksIGRvdCggcDQsIHg0ICkgKSApICkgO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIHNub2lzZTMoIHZlYzMgeCApe1xyXG4gICAgICAgIGZsb2F0IHMgID0gc25vaXNlKHZlYzMoIHggKSk7XHJcbiAgICAgICAgZmxvYXQgczEgPSBzbm9pc2UodmVjMyggeC55IC0gMTkuMSAsIHgueiArIDMzLjQgLCB4LnggKyA0Ny4yICkpO1xyXG4gICAgICAgIGZsb2F0IHMyID0gc25vaXNlKHZlYzMoIHgueiArIDc0LjIgLCB4LnggLSAxMjQuNSAsIHgueSArIDk5LjQgKSk7XHJcbiAgICAgICAgdmVjMyBjID0gdmVjMyggcyAsIHMxICwgczIgKTtcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBzbm9pc2UzKCB2ZWM0IHggKXtcclxuICAgICAgICBmbG9hdCBzICA9IHNub2lzZSh2ZWM0KCB4ICkpO1xyXG4gICAgICAgIGZsb2F0IHMxID0gc25vaXNlKHZlYzQoIHgueSAtIDE5LjEgLCB4LnogKyAzMy40ICwgeC54ICsgNDcuMiwgeC53ICkpO1xyXG4gICAgICAgIGZsb2F0IHMyID0gc25vaXNlKHZlYzQoIHgueiArIDc0LjIgLCB4LnggLSAxMjQuNSAsIHgueSArIDk5LjQsIHgudyApKTtcclxuICAgICAgICB2ZWMzIGMgPSB2ZWMzKCBzICwgczEgLCBzMiApO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgXHJcbiAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xyXG4gICAgdW5pZm9ybSB2ZWMyIHVfbW91c2U7IFxyXG4gICAgdW5pZm9ybSBmbG9hdCB1X3RpbWU7XHJcbiAgICB2ZWMyIHJhdGlvKGluIHZlYzIgc3QsIGluIHZlYzIgcykge1xyXG4gICAgICAgIHJldHVybiBtaXgoIHZlYzIoKHN0Lngqcy54L3MueSktKHMueCouNS1zLnkqLjUpL3MueSxzdC55KSxcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyKHN0Lngsc3QueSoocy55L3MueCktKHMueSouNS1zLngqLjUpL3MueCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcChzLngscy55KSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX09DVEFWRVNcclxuICAgICNkZWZpbmUgRkJNX09DVEFWRVMgNFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX05PSVNFX0ZOQ1xyXG4gICAgI2RlZmluZSBGQk1fTk9JU0VfRk5DKFBPU19VVikgc25vaXNlKFBPU19VVilcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9WQUxVRV9JTklUSUFMXHJcbiAgICAjZGVmaW5lIEZCTV9WQUxVRV9JTklUSUFMIDAuMFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX1NDQUxFX1NDQUxBUlxyXG4gICAgI2RlZmluZSBGQk1fU0NBTEVfU0NBTEFSIDIuMFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX0FNUExJVFVEX0lOSVRJQUxcclxuICAgICNkZWZpbmUgRkJNX0FNUExJVFVEX0lOSVRJQUwgMC41XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fQU1QTElUVURfU0NBTEFSXHJcbiAgICAjZGVmaW5lIEZCTV9BTVBMSVRVRF9TQ0FMQVIgMC41XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfRkJNXHJcbiAgICAjZGVmaW5lIEZOQ19GQk1cclxuICAgIGZsb2F0IGZibShpbiB2ZWMyIHN0KSB7XHJcbiAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICBmbG9hdCB2YWx1ZSA9IEZCTV9WQUxVRV9JTklUSUFMO1xyXG4gICAgICAgIGZsb2F0IGFtcGxpdHVkID0gRkJNX0FNUExJVFVEX0lOSVRJQUw7XHJcbiAgICBcclxuICAgICAgICAvLyBMb29wIG9mIG9jdGF2ZXNcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZCTV9PQ1RBVkVTOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgKz0gYW1wbGl0dWQgKiBGQk1fTk9JU0VfRk5DKHN0KTtcclxuICAgICAgICAgICAgc3QgKj0gRkJNX1NDQUxFX1NDQUxBUjtcclxuICAgICAgICAgICAgYW1wbGl0dWQgKj0gRkJNX0FNUExJVFVEX1NDQUxBUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmbG9hdCBmYm0oaW4gdmVjMyBwb3MpIHtcclxuICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xyXG4gICAgICAgIGZsb2F0IHZhbHVlID0gRkJNX1ZBTFVFX0lOSVRJQUw7XHJcbiAgICAgICAgZmxvYXQgYW1wbGl0dWQgPSBGQk1fQU1QTElUVURfSU5JVElBTDtcclxuICAgIFxyXG4gICAgICAgIC8vIExvb3Agb2Ygb2N0YXZlc1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRkJNX09DVEFWRVM7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZSArPSBhbXBsaXR1ZCAqIEZCTV9OT0lTRV9GTkMocG9zKTtcclxuICAgICAgICAgICAgcG9zICo9IEZCTV9TQ0FMRV9TQ0FMQVI7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkICo9IEZCTV9BTVBMSVRVRF9TQ0FMQVI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgdmVjMiBzdCA9IGdsX0ZyYWdDb29yZC54eS91X3Jlc29sdXRpb24ueHk7XHJcbiAgICAgICAgc3QgPSByYXRpbyhzdCwgdV9yZXNvbHV0aW9uKTtcclxuICAgIFxyXG4gICAgICAgIGZsb2F0IG4gPSAwLjQgKyBzbm9pc2UodmVjMyhzdCwgdV90aW1lKSkgKiAwLjg7XHJcbiAgICBcclxuICAgICAgICBmbG9hdCBub2lzZSA9IGZibSh2ZWMzKHN0LCB1X3RpbWUvMTAuKSk7XHJcbiAgICAgICAgZmxvYXQgbm9pc2UyID0gZmJtKHZlYzMoc3QsIG5vaXNlKSk7XHJcbiAgICAgICAgZmxvYXQgbm9pc2UzID0gZmJtKHZlYzMoc3QsIG5vaXNlMikpO1xyXG4gICAgICAgIGZsb2F0IG5vaXNlNCA9IGZibSh2ZWMzKHN0LCBub2lzZTMpKTtcclxuICAgIFxyXG4gICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKHN0Lngsc3QueSwgMS4pO1xyXG4gICAgXHJcbiAgICAgICAgY29sb3IgKz0gbm9pc2U0O1xyXG4gICAgXHJcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwxLjApO1xyXG4gICAgfWBcclxuICB9LFxyXG4gIHJheW1hcmNoaW5nOiB7XHJcbiAgICBmcmFnbWVudFNoYWRlcjogYCNpZmRlZiBHTF9FU1xyXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcclxuICAgIHVuaWZvcm0gZmxvYXQgdV90aW1lO1xyXG4gICAgZmxvYXQgUEkgPSAzLjE0MTU1OTI1O1xyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19SQVRJT1xyXG4gICAgI2RlZmluZSBGTkNfUkFUSU9cclxuICAgIHZlYzIgcmF0aW8oaW4gdmVjMiBzdCwgaW4gdmVjMiBzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1peCggdmVjMigoc3QueCpzLngvcy55KS0ocy54Ki41LXMueSouNSkvcy55LHN0LnkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIoc3QueCxzdC55KihzLnkvcy54KS0ocy55Ki41LXMueCouNSkvcy54KSxcclxuICAgICAgICAgICAgICAgICAgICBzdGVwKHMueCxzLnkpKTtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gICAgZmxvYXQgc2RTcGhlcmUodmVjMyBwLCBmbG9hdCByKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlbmd0aChwKS1yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBtYXQ0IHJvdGF0aW9uTWF0cml4KHZlYzMgYXhpcywgZmxvYXQgYW5nbGUpIHtcclxuICAgICAgICBheGlzID0gbm9ybWFsaXplKGF4aXMpO1xyXG4gICAgICAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpO1xyXG4gICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpO1xyXG4gICAgICAgIGZsb2F0IG9jID0gMS4wIC0gYztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbWF0NChvYyAqIGF4aXMueCAqIGF4aXMueCArIGMsICAgICAgICAgICBvYyAqIGF4aXMueCAqIGF4aXMueSAtIGF4aXMueiAqIHMsICBvYyAqIGF4aXMueiAqIGF4aXMueCArIGF4aXMueSAqIHMsICAwLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgKyBheGlzLnogKiBzLCAgb2MgKiBheGlzLnkgKiBheGlzLnkgKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnkgKiBheGlzLnogLSBheGlzLnggKiBzLCAgMC4wLFxyXG4gICAgICAgICAgICAgICAgICAgIG9jICogYXhpcy56ICogYXhpcy54IC0gYXhpcy55ICogcywgIG9jICogYXhpcy55ICogYXhpcy56ICsgYXhpcy54ICogcywgIG9jICogYXhpcy56ICogYXhpcy56ICsgYywgICAgICAgICAgIDAuMCxcclxuICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIHJvdGF0ZSh2ZWMzIHYsIHZlYzMgYXhpcywgZmxvYXQgYW5nbGUpIHtcclxuICAgICAgbWF0NCBtID0gcm90YXRpb25NYXRyaXgoYXhpcywgYW5nbGUpO1xyXG4gICAgICByZXR1cm4gKG0gKiB2ZWM0KHYsIDEuMCkpLnh5ejtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgc2RCb3goIHZlYzMgcCwgdmVjMyBiIClcclxuICAgIHtcclxuICAgICAgdmVjMyBxID0gYWJzKHApIC0gYjtcclxuICAgICAgcmV0dXJuIGxlbmd0aChtYXgocSwwLjApKSArIG1pbihtYXgocS54LG1heChxLnkscS56KSksMC4wKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gcG9seW5vbWlhbCBzbW9vdGggbWluIChrID0gMC4xKTtcclxuICAgIGZsb2F0IHNtaW4oIGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IGsgKVxyXG4gICAge1xyXG4gICAgICAgIGZsb2F0IGggPSBjbGFtcCggMC41KzAuNSooYi1hKS9rLCAwLjAsIDEuMCApO1xyXG4gICAgICAgIHJldHVybiBtaXgoIGIsIGEsIGggKSAtIGsqaCooMS4wLWgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmbG9hdCBzZGYodmVjMyBwKSB7XHJcbiAgICAgICAgdmVjMyBwMSA9IHJvdGF0ZShwLCB2ZWMzKDEuKSwgdV90aW1lLzIuKTtcclxuICAgICAgICAvLyBmbG9hdCBib3ggPSBzZEJveChwMSwgdmVjMygwLjMpKTtcclxuICAgICAgICBmbG9hdCBib3ggPSBzbWluKHNkQm94KHAxLCB2ZWMzKDAuMikpLCBzZFNwaGVyZShwLCAwLjIpLCAuMik7XHJcbiAgICBcclxuICAgICAgICBmbG9hdCBzcGhlcmUgPSBzZFNwaGVyZShwIC0gdmVjMyguNSwgLjQ5MSwgMC4pLCAwLjIpO1xyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIHNtaW4oYm94LCBzcGhlcmUsIC40KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBjYWxjTm9ybWFsKCBpbiB2ZWMzIHAgKSAvLyBmb3IgZnVuY3Rpb24gZihwKVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGZsb2F0IGVwcyA9IDAuMDAwMTsgLy8gb3Igc29tZSBvdGhlciB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IHZlYzIgaCA9IHZlYzIoZXBzLDApO1xyXG4gICAgICAgIHJldHVybiBub3JtYWxpemUoIHZlYzMoc2RmKHAraC54eXkpIC0gc2RmKHAtaC54eXkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2RmKHAraC55eHkpIC0gc2RmKHAtaC55eHkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2RmKHAraC55eXgpIC0gc2RmKHAtaC55eXgpICkgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIGZsb2F0IGx1bWEodmVjMyBjb2xvcikge1xyXG4gICAgICByZXR1cm4gZG90KGNvbG9yLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgbHVtYSh2ZWM0IGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiBkb3QoY29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBmbG9hdCBkaXRoZXI4eDgodmVjMiBwb3NpdGlvbiwgZmxvYXQgYnJpZ2h0bmVzcykge1xyXG4gICAgICBpbnQgeCA9IGludChtb2QocG9zaXRpb24ueCwgOC4wKSk7XHJcbiAgICAgIGludCB5ID0gaW50KG1vZChwb3NpdGlvbi55LCA4LjApKTtcclxuICAgICAgaW50IGluZGV4ID0geCArIHkgKiA4O1xyXG4gICAgICBmbG9hdCBsaW1pdCA9IDAuMDtcclxuICAgIFxyXG4gICAgICBpZiAoeCA8IDgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMCkgbGltaXQgPSAwLjAxNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMSkgbGltaXQgPSAwLjUxNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMikgbGltaXQgPSAwLjE0MDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMykgbGltaXQgPSAwLjY0MDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNCkgbGltaXQgPSAwLjA0Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNSkgbGltaXQgPSAwLjU0Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNikgbGltaXQgPSAwLjE3MTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNykgbGltaXQgPSAwLjY3MTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOCkgbGltaXQgPSAwLjc2NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOSkgbGltaXQgPSAwLjI2NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTApIGxpbWl0ID0gMC44OTA2MjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDExKSBsaW1pdCA9IDAuMzkwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxMikgbGltaXQgPSAwLjc5Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTMpIGxpbWl0ID0gMC4yOTY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDE0KSBsaW1pdCA9IDAuOTIxODc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxNSkgbGltaXQgPSAwLjQyMTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTYpIGxpbWl0ID0gMC4yMDMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDE3KSBsaW1pdCA9IDAuNzAzMTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxOCkgbGltaXQgPSAwLjA3ODEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTkpIGxpbWl0ID0gMC41NzgxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIwKSBsaW1pdCA9IDAuMjM0Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyMSkgbGltaXQgPSAwLjczNDM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjIpIGxpbWl0ID0gMC4xMDkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIzKSBsaW1pdCA9IDAuNjA5Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyNCkgbGltaXQgPSAwLjk1MzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjUpIGxpbWl0ID0gMC40NTMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDI2KSBsaW1pdCA9IDAuODI4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyNykgbGltaXQgPSAwLjMyODEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjgpIGxpbWl0ID0gMC45ODQzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDI5KSBsaW1pdCA9IDAuNDg0Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAzMCkgbGltaXQgPSAwLjg1OTM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzEpIGxpbWl0ID0gMC4zNTkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDMyKSBsaW1pdCA9IDAuMDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzMpIGxpbWl0ID0gMC41NjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAzNCkgbGltaXQgPSAwLjE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDM1KSBsaW1pdCA9IDAuNjg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzYpIGxpbWl0ID0gMC4wMzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzcpIGxpbWl0ID0gMC41MzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzgpIGxpbWl0ID0gMC4xNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzkpIGxpbWl0ID0gMC42NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNDApIGxpbWl0ID0gMC44MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0MSkgbGltaXQgPSAwLjMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDQyKSBsaW1pdCA9IDAuOTM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNDMpIGxpbWl0ID0gMC40Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NCkgbGltaXQgPSAwLjc4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NSkgbGltaXQgPSAwLjI4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NikgbGltaXQgPSAwLjkwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NykgbGltaXQgPSAwLjQwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0OCkgbGltaXQgPSAwLjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0OSkgbGltaXQgPSAwLjc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA1MCkgbGltaXQgPSAwLjEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTEpIGxpbWl0ID0gMC42MjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUyKSBsaW1pdCA9IDAuMjE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUzKSBsaW1pdCA9IDAuNzE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU0KSBsaW1pdCA9IDAuMDkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU1KSBsaW1pdCA9IDAuNTkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU2KSBsaW1pdCA9IDEuMDtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTcpIGxpbWl0ID0gMC41O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA1OCkgbGltaXQgPSAwLjg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTkpIGxpbWl0ID0gMC4zNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYwKSBsaW1pdCA9IDAuOTY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYxKSBsaW1pdCA9IDAuNDY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYyKSBsaW1pdCA9IDAuODQzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYzKSBsaW1pdCA9IDAuMzQzNzU7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICByZXR1cm4gYnJpZ2h0bmVzcyA8IGxpbWl0ID8gMC4wIDogMS4wO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIGRpdGhlcjh4OCh2ZWMyIHBvc2l0aW9uLCB2ZWMzIGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiBjb2xvciAqIGRpdGhlcjh4OChwb3NpdGlvbiwgbHVtYShjb2xvcikpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IGRpdGhlcjh4OCh2ZWMyIHBvc2l0aW9uLCB2ZWM0IGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiB2ZWM0KGNvbG9yLnJnYiAqIGRpdGhlcjh4OChwb3NpdGlvbiwgbHVtYShjb2xvcikpLCAxLjApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgIHZlYzIgc3QgPSBnbF9GcmFnQ29vcmQueHkvdV9yZXNvbHV0aW9uLnh5O1xyXG4gICAgICAgIHN0ID0gcmF0aW8oc3QsIHVfcmVzb2x1dGlvbik7XHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgZmxvYXQgZGlzdCA9IGxlbmd0aChzdCAtIHZlYzIoMC41KSk7XHJcbiAgICAgICAgdmVjMyBiZyA9IG1peCh2ZWMzKDAuKSwgdmVjMyguMyksIGRpc3QpO1xyXG4gICAgICAgIHZlYzMgY2FtUG9zID0gdmVjMygwLiwgMC4sIDMuKTtcclxuICAgICAgICB2ZWMzIHJheSA9IG5vcm1hbGl6ZSh2ZWMzKHN0IC0gLjUsIC0xLjUpKTtcclxuICAgIFxyXG4gICAgICAgIHZlYzMgcmF5UG9zID0gY2FtUG9zO1xyXG4gICAgICAgIGZsb2F0IHQgPSAwLjtcclxuICAgICAgICBmbG9hdCB0TWF4ID0gNS47XHJcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICAgICAgICB2ZWMzIHBvcyA9IGNhbVBvcyArIHQqcmF5O1xyXG4gICAgICAgICAgICBmbG9hdCBoID0gc2RmKHBvcyk7XHJcbiAgICAgICAgICAgIGlmIChoIDwgMC4wMDAxIHx8IHQgPiB0TWF4KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhazsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCArPSBoO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIGNvbG9yID0gYmc7IFxyXG4gICAgXHJcbiAgICAgICAgaWYgKHQgPCB0TWF4KSB7XHJcbiAgICAgICAgICAgIHZlYzMgcG9zID0gY2FtUG9zICsgdCpyYXk7XHJcbiAgICAgICAgICAgIGNvbG9yID0gdmVjMygxLik7XHJcbiAgICAgICAgICAgIHZlYzMgbm9ybWFsID0gY2FsY05vcm1hbChwb3MpO1xyXG4gICAgICAgICAgICBjb2xvciA9IG5vcm1hbDtcclxuICAgICAgICAgICAgZmxvYXQgZGlmZiA9IGRvdCh2ZWMzKDEuKSwgbm9ybWFsKTtcclxuICAgICAgICAgICAgY29sb3IgPSB2ZWMzKGRpZmYpO1xyXG4gICAgICAgICAgICBmbG9hdCBmcmVzbmVsID0gcG93KDEuICsgZG90KHJheSwgbm9ybWFsKSwgMS4pO1xyXG4gICAgICAgICAgICBjb2xvciA9IHZlYzMoZnJlc25lbCk7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbWl4KGNvbG9yLCBiZywgLWZyZXNuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwxLjApO1xyXG4gICAgfWBcclxuICB9LFxyXG4gIGZibToge1xyXG4gICAgZnJhZ21lbnRTaGFkZXI6IGAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZuZGVmIEZOQ19NT0QyODlcclxuICAgICNkZWZpbmUgRk5DX01PRDI4OVxyXG4gICAgZmxvYXQgbW9kMjg5KGluIGZsb2F0IHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMiBtb2QyODkoaW4gdmVjMiB4KSB7XHJcbiAgICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzMgbW9kMjg5KGluIHZlYzMgeCkge1xyXG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IG1vZDI4OShpbiB2ZWM0IHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgI2lmbmRlZiBGTkNfUEVSTVVURVxyXG4gICAgI2RlZmluZSBGTkNfUEVSTVVURVxyXG4gICAgZmxvYXQgcGVybXV0ZShpbiBmbG9hdCB4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZDI4OSgoKHggKiAzNC4pICsgMS4pKngpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIHBlcm11dGUoaW4gdmVjMyB4KSB7XHJcbiAgICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzQgcGVybXV0ZShpbiB2ZWM0IHgpIHtcclxuICAgICAgICByZXR1cm4gbW9kMjg5KCgoeCAqIDM0LikgKyAxLikqeCk7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfVEFZTE9SSU5WU1FSVFxyXG4gICAgI2RlZmluZSBGTkNfVEFZTE9SSU5WU1FSVFxyXG4gICAgZmxvYXQgdGF5bG9ySW52U3FydChpbiBmbG9hdCByKSB7XHJcbiAgICAgIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzQgdGF5bG9ySW52U3FydChpbiB2ZWM0IHIpIHtcclxuICAgICAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgI2lmbmRlZiBGTkNfR1JBRDRcclxuICAgICNkZWZpbmUgRk5DX0dSQUQ0XHJcbiAgICB2ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApIHtcclxuICAgICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xyXG4gICAgICAgIHZlYzQgcCxzO1xyXG4gICAgXHJcbiAgICAgICAgcC54eXogPSBmbG9vciggZnJhY3QgKHZlYzMoaikgKiBpcC54eXopICogNy4wKSAqIGlwLnogLSAxLjA7XHJcbiAgICAgICAgcC53ID0gMS41IC0gZG90KGFicyhwLnh5eiksIG9uZXMueHl6KTtcclxuICAgICAgICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcclxuICAgICAgICBwLnh5eiA9IHAueHl6ICsgKHMueHl6KjIuMCAtIDEuMCkgKiBzLnd3dztcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIFxyXG4gICAgLypcclxuICAgIGF1dGhvcjogW0lhbiBNY0V3YW4sIEFzaGltYSBBcnRzXVxyXG4gICAgZGVzY3JpcHRpb246IFNpbXBsZXggTm9pc2UgaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxyXG4gICAgdXNlOiBzbm9pc2UoPHZlYzJ8dmVjM3x2ZWM0PiBwb3MpXHJcbiAgICBsaWNlbnNlOiB8XHJcbiAgICAgIENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAgQ29weXJpZ2h0IChDKSAyMDExLTIwMTYgYnkgU3RlZmFuIEd1c3RhdnNvbiAoQ2xhc3NpYyBub2lzZSBhbmQgb3RoZXJzKVxyXG4gICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAgICAgIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAgICAgUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gICAgICBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBHUFVJbWFnZSBmcmFtZXdvcmsgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAgXHJcbiAgICAqL1xyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19TTk9JU0VcclxuICAgICNkZWZpbmUgRk5DX1NOT0lTRVxyXG4gICAgZmxvYXQgc25vaXNlKGluIHZlYzIgdikge1xyXG4gICAgICAgIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsICAvLyAoMy4wLXNxcnQoMy4wKSkvNi4wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjM2NjAyNTQwMzc4NDQzOSwgIC8vIDAuNSooc3FydCgzLjApLTEuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0wLjU3NzM1MDI2OTE4OTYyNiwgIC8vIC0xLjAgKyAyLjAgKiBDLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMDI0MzkwMjQzOTAyNDM5KTsgLy8gMS4wIC8gNDEuMFxyXG4gICAgICAgIC8vIEZpcnN0IGNvcm5lclxyXG4gICAgICAgIHZlYzIgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpICk7XHJcbiAgICAgICAgdmVjMiB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eCk7XHJcbiAgICBcclxuICAgICAgICAvLyBPdGhlciBjb3JuZXJzXHJcbiAgICAgICAgdmVjMiBpMTtcclxuICAgICAgICAvL2kxLnggPSBzdGVwKCB4MC55LCB4MC54ICk7IC8vIHgwLnggPiB4MC55ID8gMS4wIDogMC4wXHJcbiAgICAgICAgLy9pMS55ID0gMS4wIC0gaTEueDtcclxuICAgICAgICBpMSA9ICh4MC54ID4geDAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xyXG4gICAgICAgIC8vIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4IDtcclxuICAgICAgICAvLyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4IDtcclxuICAgICAgICAvLyB4MiA9IHgwIC0gMS4wICsgMi4wICogQy54eCA7XHJcbiAgICAgICAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xyXG4gICAgICAgIHgxMi54eSAtPSBpMTtcclxuICAgIFxyXG4gICAgICAgIC8vIFBlcm11dGF0aW9uc1xyXG4gICAgICAgIGkgPSBtb2QyODkoaSk7IC8vIEF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxyXG4gICAgICAgIHZlYzMgcCA9IHBlcm11dGUoIHBlcm11dGUoIGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjAgKSlcclxuICAgICAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjAgKSk7XHJcbiAgICBcclxuICAgICAgICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEyLnh5LHgxMi54eSksIGRvdCh4MTIuencseDEyLnp3KSksIDAuMCk7XHJcbiAgICAgICAgbSA9IG0qbSA7XHJcbiAgICAgICAgbSA9IG0qbSA7XHJcbiAgICBcclxuICAgICAgICAvLyBHcmFkaWVudHM6IDQxIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIGxpbmUsIG1hcHBlZCBvbnRvIGEgZGlhbW9uZC5cclxuICAgICAgICAvLyBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGUgb2YgNDEgKDQxKjcgPSAyODcpXHJcbiAgICBcclxuICAgICAgICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xyXG4gICAgICAgIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcclxuICAgICAgICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XHJcbiAgICAgICAgdmVjMyBhMCA9IHggLSBveDtcclxuICAgIFxyXG4gICAgICAgIC8vIE5vcm1hbGlzZSBncmFkaWVudHMgaW1wbGljaXRseSBieSBzY2FsaW5nIG1cclxuICAgICAgICAvLyBBcHByb3hpbWF0aW9uIG9mOiBtICo9IGludmVyc2VzcXJ0KCBhMCphMCArIGgqaCApO1xyXG4gICAgICAgIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoIGEwKmEwICsgaCpoICk7XHJcbiAgICBcclxuICAgICAgICAvLyBDb21wdXRlIGZpbmFsIG5vaXNlIHZhbHVlIGF0IFBcclxuICAgICAgICB2ZWMzIGc7XHJcbiAgICAgICAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcclxuICAgICAgICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xyXG4gICAgICAgIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBmbG9hdCBzbm9pc2UoaW4gdmVjMyB2KSB7XHJcbiAgICAgICAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCkgO1xyXG4gICAgICAgIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XHJcbiAgICBcclxuICAgICAgICAvLyBGaXJzdCBjb3JuZXJcclxuICAgICAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcclxuICAgICAgICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xyXG4gICAgXHJcbiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgICAgIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xyXG4gICAgICAgIHZlYzMgbCA9IDEuMCAtIGc7XHJcbiAgICAgICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XHJcbiAgICAgICAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XHJcbiAgICBcclxuICAgICAgICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcclxuICAgICAgICB2ZWMzIHgxID0geDAgLSBpMSArIEMueHh4O1xyXG4gICAgICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcclxuICAgICAgICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxyXG4gICAgXHJcbiAgICAgICAgLy8gUGVybXV0YXRpb25zXHJcbiAgICAgICAgaSA9IG1vZDI4OShpKTtcclxuICAgICAgICB2ZWM0IHAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXHJcbiAgICAgICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxyXG4gICAgICAgIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcclxuICAgICAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcclxuICAgIFxyXG4gICAgICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKiBucy56KTsgIC8vICBtb2QocCw3KjcpXHJcbiAgICBcclxuICAgICAgICB2ZWM0IHhfID0gZmxvb3IoaiAqIG5zLnopO1xyXG4gICAgICAgIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcclxuICAgIFxyXG4gICAgICAgIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcclxuICAgICAgICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XHJcbiAgICAgICAgdmVjNCBoID0gMS4wIC0gYWJzKHgpIC0gYWJzKHkpO1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcclxuICAgICAgICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xyXG4gICAgXHJcbiAgICAgICAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XHJcbiAgICAgICAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XHJcbiAgICAgICAgdmVjNCBzMCA9IGZsb29yKGIwKSoyLjAgKyAxLjA7XHJcbiAgICAgICAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XHJcbiAgICAgICAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XHJcbiAgICBcclxuICAgICAgICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XHJcbiAgICAgICAgdmVjNCBhMSA9IGIxLnh6eXcgKyBzMS54enl3KnNoLnp6d3cgO1xyXG4gICAgXHJcbiAgICAgICAgdmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcclxuICAgICAgICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xyXG4gICAgICAgIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XHJcbiAgICAgICAgdmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcclxuICAgIFxyXG4gICAgICAgIC8vTm9ybWFsaXNlIGdyYWRpZW50c1xyXG4gICAgICAgIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xyXG4gICAgICAgIHAwICo9IG5vcm0ueDtcclxuICAgICAgICBwMSAqPSBub3JtLnk7XHJcbiAgICAgICAgcDIgKj0gbm9ybS56O1xyXG4gICAgICAgIHAzICo9IG5vcm0udztcclxuICAgIFxyXG4gICAgICAgIC8vIE1peCBmaW5hbCBub2lzZSB2YWx1ZVxyXG4gICAgICAgIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xyXG4gICAgICAgIG0gPSBtICogbTtcclxuICAgICAgICByZXR1cm4gNDIuMCAqIGRvdCggbSptLCB2ZWM0KCBkb3QocDAseDApLCBkb3QocDEseDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgc25vaXNlKGluIHZlYzQgdikge1xyXG4gICAgICAgIGNvbnN0IHZlYzQgIEMgPSB2ZWM0KCAwLjEzODE5NjYwMTEyNTAxMSwgIC8vICg1IC0gc3FydCg1KSkvMjAgIEc0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC40MTQ1ODk4MDMzNzUwMzIsICAvLyAzICogRzRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0wLjQ0NzIxMzU5NTQ5OTk1OCk7IC8vIC0xICsgNCAqIEc0XHJcbiAgICBcclxuICAgICAgICAvLyBGaXJzdCBjb3JuZXJcclxuICAgICAgICB2ZWM0IGkgID0gZmxvb3IodiArIGRvdCh2LCB2ZWM0KC4zMDkwMTY5OTQzNzQ5NDc0NTEpKSApOyAvLyAoc3FydCg1KSAtIDEpLzRcclxuICAgICAgICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmFuayBzb3J0aW5nIG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgYnkgQmlsbCBMaWNlYS1LYW5lLCBBTUQgKGZvcm1lcmx5IEFUSSlcclxuICAgICAgICB2ZWM0IGkwO1xyXG4gICAgICAgIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcclxuICAgICAgICB2ZWMzIGlzWVogPSBzdGVwKCB4MC56d3csIHgwLnl5eiApO1xyXG4gICAgICAgIC8vICBpMC54ID0gZG90KCBpc1gsIHZlYzMoIDEuMCApICk7XHJcbiAgICAgICAgaTAueCA9IGlzWC54ICsgaXNYLnkgKyBpc1guejtcclxuICAgICAgICBpMC55encgPSAxLjAgLSBpc1g7XHJcbiAgICAgICAgLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xyXG4gICAgICAgIGkwLnkgKz0gaXNZWi54ICsgaXNZWi55O1xyXG4gICAgICAgIGkwLnp3ICs9IDEuMCAtIGlzWVoueHk7XHJcbiAgICAgICAgaTAueiArPSBpc1laLno7XHJcbiAgICAgICAgaTAudyArPSAxLjAgLSBpc1laLno7XHJcbiAgICBcclxuICAgICAgICAvLyBpMCBub3cgY29udGFpbnMgdGhlIHVuaXF1ZSB2YWx1ZXMgMCwxLDIsMyBpbiBlYWNoIGNoYW5uZWxcclxuICAgICAgICB2ZWM0IGkzID0gY2xhbXAoIGkwLCAwLjAsIDEuMCApO1xyXG4gICAgICAgIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xyXG4gICAgICAgIHZlYzQgaTEgPSBjbGFtcCggaTAtMi4wLCAwLjAsIDEuMCApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4eFxyXG4gICAgICAgIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XHJcbiAgICAgICAgLy8gIHgzID0geDAgLSBpMyAgKyAzLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEMueHh4eFxyXG4gICAgICAgIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xyXG4gICAgICAgIHZlYzQgeDIgPSB4MCAtIGkyICsgQy55eXl5O1xyXG4gICAgICAgIHZlYzQgeDMgPSB4MCAtIGkzICsgQy56enp6O1xyXG4gICAgICAgIHZlYzQgeDQgPSB4MCArIEMud3d3dztcclxuICAgIFxyXG4gICAgICAgIC8vIFBlcm11dGF0aW9uc1xyXG4gICAgICAgIGkgPSBtb2QyODkoaSk7XHJcbiAgICAgICAgZmxvYXQgajAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKGkudykgKyBpLnopICsgaS55KSArIGkueCk7XHJcbiAgICAgICAgdmVjNCBqMSA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUgKFxyXG4gICAgICAgICAgICAgICAgICAgIGkudyArIHZlYzQoaTEudywgaTIudywgaTMudywgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueiArIHZlYzQoaTEueiwgaTIueiwgaTMueiwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueSArIHZlYzQoaTEueSwgaTIueSwgaTMueSwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueCArIHZlYzQoaTEueCwgaTIueCwgaTMueCwgMS4wICkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxyXG4gICAgICAgIC8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxyXG4gICAgICAgIHZlYzQgaXAgPSB2ZWM0KDEuMC8yOTQuMCwgMS4wLzQ5LjAsIDEuMC83LjAsIDAuMCkgO1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBwMCA9IGdyYWQ0KGowLCAgIGlwKTtcclxuICAgICAgICB2ZWM0IHAxID0gZ3JhZDQoajEueCwgaXApO1xyXG4gICAgICAgIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XHJcbiAgICAgICAgdmVjNCBwMyA9IGdyYWQ0KGoxLnosIGlwKTtcclxuICAgICAgICB2ZWM0IHA0ID0gZ3JhZDQoajEudywgaXApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50c1xyXG4gICAgICAgIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xyXG4gICAgICAgIHAwICo9IG5vcm0ueDtcclxuICAgICAgICBwMSAqPSBub3JtLnk7XHJcbiAgICAgICAgcDIgKj0gbm9ybS56O1xyXG4gICAgICAgIHAzICo9IG5vcm0udztcclxuICAgICAgICBwNCAqPSB0YXlsb3JJbnZTcXJ0KGRvdChwNCxwNCkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXHJcbiAgICAgICAgdmVjMyBtMCA9IG1heCgwLjYgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MikpLCAwLjApO1xyXG4gICAgICAgIHZlYzIgbTEgPSBtYXgoMC42IC0gdmVjMihkb3QoeDMseDMpLCBkb3QoeDQseDQpICAgICAgICAgICAgKSwgMC4wKTtcclxuICAgICAgICBtMCA9IG0wICogbTA7XHJcbiAgICAgICAgbTEgPSBtMSAqIG0xO1xyXG4gICAgICAgIHJldHVybiA0OS4wICogKCBkb3QobTAqbTAsIHZlYzMoIGRvdCggcDAsIHgwICksIGRvdCggcDEsIHgxICksIGRvdCggcDIsIHgyICkpKVxyXG4gICAgICAgICAgICAgICAgICAgICsgZG90KG0xKm0xLCB2ZWMyKCBkb3QoIHAzLCB4MyApLCBkb3QoIHA0LCB4NCApICkgKSApIDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBzbm9pc2UzKCB2ZWMzIHggKXtcclxuICAgICAgICBmbG9hdCBzICA9IHNub2lzZSh2ZWMzKCB4ICkpO1xyXG4gICAgICAgIGZsb2F0IHMxID0gc25vaXNlKHZlYzMoIHgueSAtIDE5LjEgLCB4LnogKyAzMy40ICwgeC54ICsgNDcuMiApKTtcclxuICAgICAgICBmbG9hdCBzMiA9IHNub2lzZSh2ZWMzKCB4LnogKyA3NC4yICwgeC54IC0gMTI0LjUgLCB4LnkgKyA5OS40ICkpO1xyXG4gICAgICAgIHZlYzMgYyA9IHZlYzMoIHMgLCBzMSAsIHMyICk7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzMgc25vaXNlMyggdmVjNCB4ICl7XHJcbiAgICAgICAgZmxvYXQgcyAgPSBzbm9pc2UodmVjNCggeCApKTtcclxuICAgICAgICBmbG9hdCBzMSA9IHNub2lzZSh2ZWM0KCB4LnkgLSAxOS4xICwgeC56ICsgMzMuNCAsIHgueCArIDQ3LjIsIHgudyApKTtcclxuICAgICAgICBmbG9hdCBzMiA9IHNub2lzZSh2ZWM0KCB4LnogKyA3NC4yICwgeC54IC0gMTI0LjUgLCB4LnkgKyA5OS40LCB4LncgKSk7XHJcbiAgICAgICAgdmVjMyBjID0gdmVjMyggcyAsIHMxICwgczIgKTtcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIFxyXG4gICAgdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcclxuICAgIHVuaWZvcm0gZmxvYXQgdV90aW1lO1xyXG4gICAgdmVjMiByYXRpbyhpbiB2ZWMyIHN0LCBpbiB2ZWMyIHMpIHtcclxuICAgICAgICByZXR1cm4gbWl4KCB2ZWMyKChzdC54KnMueC9zLnkpLShzLngqLjUtcy55Ki41KS9zLnksc3QueSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMihzdC54LHN0LnkqKHMueS9zLngpLShzLnkqLjUtcy54Ki41KS9zLngpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAocy54LHMueSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9PQ1RBVkVTXHJcbiAgICAjZGVmaW5lIEZCTV9PQ1RBVkVTIDRcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9OT0lTRV9GTkNcclxuICAgICNkZWZpbmUgRkJNX05PSVNFX0ZOQyhQT1NfVVYpIHNub2lzZShQT1NfVVYpXHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGQk1fVkFMVUVfSU5JVElBTFxyXG4gICAgI2RlZmluZSBGQk1fVkFMVUVfSU5JVElBTCAwLjBcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9TQ0FMRV9TQ0FMQVJcclxuICAgICNkZWZpbmUgRkJNX1NDQUxFX1NDQUxBUiAyLjBcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZCTV9BTVBMSVRVRF9JTklUSUFMXHJcbiAgICAjZGVmaW5lIEZCTV9BTVBMSVRVRF9JTklUSUFMIDAuNVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRkJNX0FNUExJVFVEX1NDQUxBUlxyXG4gICAgI2RlZmluZSBGQk1fQU1QTElUVURfU0NBTEFSIDAuNVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX0ZCTVxyXG4gICAgI2RlZmluZSBGTkNfRkJNXHJcbiAgICBmbG9hdCBmYm0oaW4gdmVjMiBzdCkge1xyXG4gICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBGQk1fVkFMVUVfSU5JVElBTDtcclxuICAgICAgICBmbG9hdCBhbXBsaXR1ZCA9IEZCTV9BTVBMSVRVRF9JTklUSUFMO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTG9vcCBvZiBvY3RhdmVzXHJcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGQk1fT0NUQVZFUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IGFtcGxpdHVkICogRkJNX05PSVNFX0ZOQyhzdCk7XHJcbiAgICAgICAgICAgIHN0ICo9IEZCTV9TQ0FMRV9TQ0FMQVI7XHJcbiAgICAgICAgICAgIGFtcGxpdHVkICo9IEZCTV9BTVBMSVRVRF9TQ0FMQVI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgZmJtKGluIHZlYzMgcG9zKSB7XHJcbiAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICBmbG9hdCB2YWx1ZSA9IEZCTV9WQUxVRV9JTklUSUFMO1xyXG4gICAgICAgIGZsb2F0IGFtcGxpdHVkID0gRkJNX0FNUExJVFVEX0lOSVRJQUw7XHJcbiAgICBcclxuICAgICAgICAvLyBMb29wIG9mIG9jdGF2ZXNcclxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZCTV9PQ1RBVkVTOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgKz0gYW1wbGl0dWQgKiBGQk1fTk9JU0VfRk5DKHBvcyk7XHJcbiAgICAgICAgICAgIHBvcyAqPSBGQk1fU0NBTEVfU0NBTEFSO1xyXG4gICAgICAgICAgICBhbXBsaXR1ZCAqPSBGQk1fQU1QTElUVURfU0NBTEFSO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgIHZlYzIgc3QgPSBnbF9GcmFnQ29vcmQueHkvdV9yZXNvbHV0aW9uLnh5O1xyXG4gICAgICAgIHZlYzIgcmF0aW9zdCA9IHJhdGlvKHN0LCB1X3Jlc29sdXRpb24pO1xyXG4gICAgXHJcbiAgICBcclxuICAgICAgICBmbG9hdCBub2lzZSA9IGZibSh2ZWMzKHJhdGlvc3QsIHVfdGltZS80MC4pKTtcclxuICAgICAgICBmbG9hdCBub2lzZTIgPSBmYm0odmVjMyhyYXRpb3N0LCBub2lzZSkpO1xyXG4gICAgICAgIGZsb2F0IG5vaXNlMyA9IGZibSh2ZWMzKHJhdGlvc3QsIG5vaXNlMikpO1xyXG4gICAgXHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgY29sb3IgPSB2ZWMzKHJhdGlvc3QueCxyYXRpb3N0LnksIDEuKTtcclxuICAgICAgICBjb2xvciArPSBub2lzZTM7XHJcbiAgICBcclxuICAgICAgICBjb2xvciAtPSBkaXN0YW5jZSh2ZWMyKHN0LnksIHN0LngpLCB2ZWMyKDAuLCBzdC54KSkqMy47XHJcbiAgICBcclxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLDEuKTtcclxuICAgIH1gXHJcbiAgfSxcclxuICB0ZW1wbGF0ZToge1xyXG4gICAgZnJhZ21lbnRTaGFkZXI6IGAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XHJcbiAgICB1bmlmb3JtIHZlYzIgdV9tb3VzZTsgXHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcclxuICAgIFxyXG4gICAgXHJcbiAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgdmVjMiBzdCA9IGdsX0ZyYWdDb29yZC54eS91X3Jlc29sdXRpb24ueHk7XHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgY29sb3IgPSB2ZWMzKHN0Lngsc3QueSxhYnMoc2luKHVfdGltZSkpKTtcclxuICAgIFxyXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsMS4wKTtcclxuICAgIH1gXHJcbiAgfSxcclxuICBkaXRoZXJUZXh0dXJlOiB7XHJcbiAgICBmcmFnbWVudFNoYWRlcjogYC8vIEF1dGhvcjpcclxuICAgIC8vIFRpdGxlOlxyXG4gICAgXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgIFxyXG4gICAgdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcclxuICAgIHVuaWZvcm0gdmVjMiB1X21vdXNlOyBcclxuICAgIHVuaWZvcm0gZmxvYXQgdV90aW1lO1xyXG4gICAgXHJcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVfMTtcclxuICAgIHVuaWZvcm0gdmVjMiB1X3RleHR1cmVfMV9SZXNvbHV0aW9uO1xyXG4gICAgXHJcbiAgICBcclxuICAgIGZsb2F0IGx1bWEodmVjMyBjb2xvcikge1xyXG4gICAgICByZXR1cm4gZG90KGNvbG9yLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgbHVtYSh2ZWM0IGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiBkb3QoY29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBmbG9hdCBkaXRoZXI4eDgodmVjMiBwb3NpdGlvbiwgZmxvYXQgYnJpZ2h0bmVzcykge1xyXG4gICAgICBpbnQgeCA9IGludChtb2QocG9zaXRpb24ueCwgOC4wKSk7XHJcbiAgICAgIGludCB5ID0gaW50KG1vZChwb3NpdGlvbi55LCA4LjApKTtcclxuICAgICAgaW50IGluZGV4ID0geCArIHkgKiA4O1xyXG4gICAgICBmbG9hdCBsaW1pdCA9IDAuMDtcclxuICAgIFxyXG4gICAgICBpZiAoeCA8IDgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMCkgbGltaXQgPSAwLjAxNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMSkgbGltaXQgPSAwLjUxNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMikgbGltaXQgPSAwLjE0MDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMykgbGltaXQgPSAwLjY0MDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNCkgbGltaXQgPSAwLjA0Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNSkgbGltaXQgPSAwLjU0Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNikgbGltaXQgPSAwLjE3MTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNykgbGltaXQgPSAwLjY3MTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOCkgbGltaXQgPSAwLjc2NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gOSkgbGltaXQgPSAwLjI2NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTApIGxpbWl0ID0gMC44OTA2MjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDExKSBsaW1pdCA9IDAuMzkwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxMikgbGltaXQgPSAwLjc5Njg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTMpIGxpbWl0ID0gMC4yOTY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDE0KSBsaW1pdCA9IDAuOTIxODc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxNSkgbGltaXQgPSAwLjQyMTg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTYpIGxpbWl0ID0gMC4yMDMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDE3KSBsaW1pdCA9IDAuNzAzMTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAxOCkgbGltaXQgPSAwLjA3ODEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMTkpIGxpbWl0ID0gMC41NzgxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIwKSBsaW1pdCA9IDAuMjM0Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyMSkgbGltaXQgPSAwLjczNDM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjIpIGxpbWl0ID0gMC4xMDkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDIzKSBsaW1pdCA9IDAuNjA5Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyNCkgbGltaXQgPSAwLjk1MzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjUpIGxpbWl0ID0gMC40NTMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDI2KSBsaW1pdCA9IDAuODI4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAyNykgbGltaXQgPSAwLjMyODEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMjgpIGxpbWl0ID0gMC45ODQzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDI5KSBsaW1pdCA9IDAuNDg0Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAzMCkgbGltaXQgPSAwLjg1OTM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzEpIGxpbWl0ID0gMC4zNTkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDMyKSBsaW1pdCA9IDAuMDYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzMpIGxpbWl0ID0gMC41NjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSAzNCkgbGltaXQgPSAwLjE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDM1KSBsaW1pdCA9IDAuNjg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzYpIGxpbWl0ID0gMC4wMzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzcpIGxpbWl0ID0gMC41MzEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzgpIGxpbWl0ID0gMC4xNTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gMzkpIGxpbWl0ID0gMC42NTYyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNDApIGxpbWl0ID0gMC44MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0MSkgbGltaXQgPSAwLjMxMjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDQyKSBsaW1pdCA9IDAuOTM3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNDMpIGxpbWl0ID0gMC40Mzc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NCkgbGltaXQgPSAwLjc4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NSkgbGltaXQgPSAwLjI4MTI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NikgbGltaXQgPSAwLjkwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0NykgbGltaXQgPSAwLjQwNjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0OCkgbGltaXQgPSAwLjI1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA0OSkgbGltaXQgPSAwLjc1O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA1MCkgbGltaXQgPSAwLjEyNTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTEpIGxpbWl0ID0gMC42MjU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUyKSBsaW1pdCA9IDAuMjE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDUzKSBsaW1pdCA9IDAuNzE4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU0KSBsaW1pdCA9IDAuMDkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU1KSBsaW1pdCA9IDAuNTkzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDU2KSBsaW1pdCA9IDEuMDtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTcpIGxpbWl0ID0gMC41O1xyXG4gICAgICAgIGlmIChpbmRleCA9PSA1OCkgbGltaXQgPSAwLjg3NTtcclxuICAgICAgICBpZiAoaW5kZXggPT0gNTkpIGxpbWl0ID0gMC4zNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYwKSBsaW1pdCA9IDAuOTY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYxKSBsaW1pdCA9IDAuNDY4NzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYyKSBsaW1pdCA9IDAuODQzNzU7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IDYzKSBsaW1pdCA9IDAuMzQzNzU7XHJcbiAgICAgIH1cclxuICAgIFxyXG4gICAgICByZXR1cm4gYnJpZ2h0bmVzcyA8IGxpbWl0ID8gMC4wIDogMS4wO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIGRpdGhlcjh4OCh2ZWMyIHBvc2l0aW9uLCB2ZWMzIGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiBjb2xvciAqIGRpdGhlcjh4OChwb3NpdGlvbiwgbHVtYShjb2xvcikpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IGRpdGhlcjh4OCh2ZWMyIHBvc2l0aW9uLCB2ZWM0IGNvbG9yKSB7XHJcbiAgICAgIHJldHVybiB2ZWM0KGNvbG9yLnJnYiAqIGRpdGhlcjh4OChwb3NpdGlvbiwgbHVtYShjb2xvcikpLCAxLjApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1JBVElPXHJcbiAgICAjZGVmaW5lIEZOQ19SQVRJT1xyXG4gICAgdmVjMiByYXRpbyhpbiB2ZWMyIHN0LCBpbiB2ZWMyIHMpIHtcclxuICAgICAgICByZXR1cm4gbWl4KCB2ZWMyKChzdC54KnMueC9zLnkpLShzLngqLjUtcy55Ki41KS9zLnksc3QueSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMihzdC54LHN0LnkqKHMueS9zLngpLShzLnkqLjUtcy54Ki41KS9zLngpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAocy54LHMueSkpO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICB2ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3VfcmVzb2x1dGlvbi54eTtcclxuICAgICAgICBzdCA9IHJhdGlvKHN0LCB1X3Jlc29sdXRpb24pO1xyXG4gICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KHN0Lngsc3QueSwwLjAsMS4wKTtcclxuICAgIFxyXG4gICAgXHJcbiAgICAgICAgZmxvYXQgZ3JpZCA9IHVfcmVzb2x1dGlvbi54LzMuNTtcclxuICAgICAgICB2ZWMyIHN0X2YgPSBmcmFjdChzdCk7XHJcbiAgICAgICAgdmVjMiBzdF9pID0gZmxvb3Ioc3QgKiBncmlkKS9ncmlkO1xyXG4gICAgICAgIC8vIHN0X2kgPSBzdDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBjb2xvciA9IHZlYzQoc3QueCxzdC55LGFicyhzaW4odV90aW1lKSksIDEuKTtcclxuICAgICAgICBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmVfMSxzdF9pKTtcclxuICAgICAgICBjb2xvciA9IHZlYzQoZGl0aGVyOHg4KGdsX0ZyYWdDb29yZC54eSwgY29sb3IpKTtcclxuICAgIFxyXG4gICAgXHJcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XHJcbiAgICB9YCxcclxuICAgIHRleHR1cmU6IFwiL2Fzc2V0cy9waWN0dXJlcy9hLmpwZ1wiXHJcbiAgfSxcclxuICBzaW1wbGV4Tm9pc2U6IHtcclxuICAgIGZyYWdtZW50U2hhZGVyOiBgICNpZmRlZiBHTF9FU1xyXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcclxuICAgIHVuaWZvcm0gdmVjMiB1X21vdXNlO1xyXG4gICAgdW5pZm9ybSBmbG9hdCB1X3RpbWU7XHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1JBVElPXHJcbiAgICAjZGVmaW5lIEZOQ19SQVRJT1xyXG4gICAgdmVjMiByYXRpbyhpbiB2ZWMyIHN0LCBpbiB2ZWMyIHMpIHtcclxuICAgICAgICByZXR1cm4gbWl4KCB2ZWMyKChzdC54KnMueC9zLnkpLShzLngqLjUtcy55Ki41KS9zLnksc3QueSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMihzdC54LHN0LnkqKHMueS9zLngpLShzLnkqLjUtcy54Ki41KS9zLngpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAocy54LHMueSkpO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZuZGVmIEZOQ19IU1YyUkdCXHJcbiAgICAjZGVmaW5lIEZOQ19IU1YyUkdCXHJcbiAgICB2ZWMzIGhzdjJyZ2IoaW4gdmVjMyBoc2IpIHtcclxuICAgICAgICB2ZWMzIHJnYiA9IGNsYW1wKGFicyhtb2QoaHNiLnggKiA2LiArIHZlYzMoMC4sIDQuLCAyLiksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYuKSAtIDMuKSAtIDEuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDEuKTtcclxuICAgICAgICAjaWZkZWYgSFNWMlJHQl9TTU9PVEhcclxuICAgICAgICByZ2IgPSByZ2IqcmdiKigzLiAtIDIuICogcmdiKTtcclxuICAgICAgICAjZW5kaWZcclxuICAgICAgICByZXR1cm4gaHNiLnogKiBtaXgodmVjMygxLiksIHJnYiwgaHNiLnkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IGhzdjJyZ2IoaW4gdmVjNCBoc2IpIHtcclxuICAgICAgICByZXR1cm4gdmVjNChoc3YycmdiKGhzYi5yZ2IpLCBoc2IuYSk7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfTU9EMjg5XHJcbiAgICAjZGVmaW5lIEZOQ19NT0QyODlcclxuICAgIGZsb2F0IG1vZDI4OShpbiBmbG9hdCB4KSB7XHJcbiAgICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzIgbW9kMjg5KGluIHZlYzIgeCkge1xyXG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4gLyAyODkuKSkgKiAyODkuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWMzIG1vZDI4OShpbiB2ZWMzIHgpIHtcclxuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuIC8gMjg5LikpICogMjg5LjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjNCBtb2QyODkoaW4gdmVjNCB4KSB7XHJcbiAgICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLiAvIDI4OS4pKSAqIDI4OS47XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfUEVSTVVURVxyXG4gICAgI2RlZmluZSBGTkNfUEVSTVVURVxyXG4gICAgZmxvYXQgcGVybXV0ZShpbiBmbG9hdCB4KSB7XHJcbiAgICAgICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuKSArIDEuKSp4KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBwZXJtdXRlKGluIHZlYzMgeCkge1xyXG4gICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IHBlcm11dGUoaW4gdmVjNCB4KSB7XHJcbiAgICAgICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuKSArIDEuKSp4KTtcclxuICAgIH1cclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1RBWUxPUklOVlNRUlRcclxuICAgICNkZWZpbmUgRk5DX1RBWUxPUklOVlNRUlRcclxuICAgIGZsb2F0IHRheWxvckludlNxcnQoaW4gZmxvYXQgcikge1xyXG4gICAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZWM0IHRheWxvckludlNxcnQoaW4gdmVjNCByKSB7XHJcbiAgICAgIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XHJcbiAgICB9XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfR1JBRDRcclxuICAgICNkZWZpbmUgRk5DX0dSQUQ0XHJcbiAgICB2ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApIHtcclxuICAgICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xyXG4gICAgICAgIHZlYzQgcCxzO1xyXG4gICAgXHJcbiAgICAgICAgcC54eXogPSBmbG9vciggZnJhY3QgKHZlYzMoaikgKiBpcC54eXopICogNy4wKSAqIGlwLnogLSAxLjA7XHJcbiAgICAgICAgcC53ID0gMS41IC0gZG90KGFicyhwLnh5eiksIG9uZXMueHl6KTtcclxuICAgICAgICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcclxuICAgICAgICBwLnh5eiA9IHAueHl6ICsgKHMueHl6KjIuMCAtIDEuMCkgKiBzLnd3dztcclxuICAgIFxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIFxyXG4gICAgLypcclxuICAgIGF1dGhvcjogW0lhbiBNY0V3YW4sIEFzaGltYSBBcnRzXVxyXG4gICAgZGVzY3JpcHRpb246IFNpbXBsZXggTm9pc2UgaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxyXG4gICAgdXNlOiBzbm9pc2UoPHZlYzJ8dmVjM3x2ZWM0PiBwb3MpXHJcbiAgICBsaWNlbnNlOiB8XHJcbiAgICAgIENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgICAgQ29weXJpZ2h0IChDKSAyMDExLTIwMTYgYnkgU3RlZmFuIEd1c3RhdnNvbiAoQ2xhc3NpYyBub2lzZSBhbmQgb3RoZXJzKVxyXG4gICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAgICAgIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAgICAgUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gICAgICBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBHUFVJbWFnZSBmcmFtZXdvcmsgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAgXHJcbiAgICAqL1xyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19TTk9JU0VcclxuICAgICNkZWZpbmUgRk5DX1NOT0lTRVxyXG4gICAgZmxvYXQgc25vaXNlKGluIHZlYzIgdikge1xyXG4gICAgICAgIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsICAvLyAoMy4wLXNxcnQoMy4wKSkvNi4wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjM2NjAyNTQwMzc4NDQzOSwgIC8vIDAuNSooc3FydCgzLjApLTEuMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0wLjU3NzM1MDI2OTE4OTYyNiwgIC8vIC0xLjAgKyAyLjAgKiBDLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMDI0MzkwMjQzOTAyNDM5KTsgLy8gMS4wIC8gNDEuMFxyXG4gICAgICAgIC8vIEZpcnN0IGNvcm5lclxyXG4gICAgICAgIHZlYzIgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpICk7XHJcbiAgICAgICAgdmVjMiB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eCk7XHJcbiAgICBcclxuICAgICAgICAvLyBPdGhlciBjb3JuZXJzXHJcbiAgICAgICAgdmVjMiBpMTtcclxuICAgICAgICAvL2kxLnggPSBzdGVwKCB4MC55LCB4MC54ICk7IC8vIHgwLnggPiB4MC55ID8gMS4wIDogMC4wXHJcbiAgICAgICAgLy9pMS55ID0gMS4wIC0gaTEueDtcclxuICAgICAgICBpMSA9ICh4MC54ID4geDAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xyXG4gICAgICAgIC8vIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4IDtcclxuICAgICAgICAvLyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4IDtcclxuICAgICAgICAvLyB4MiA9IHgwIC0gMS4wICsgMi4wICogQy54eCA7XHJcbiAgICAgICAgdmVjNCB4MTIgPSB4MC54eXh5ICsgQy54eHp6O1xyXG4gICAgICAgIHgxMi54eSAtPSBpMTtcclxuICAgIFxyXG4gICAgICAgIC8vIFBlcm11dGF0aW9uc1xyXG4gICAgICAgIGkgPSBtb2QyODkoaSk7IC8vIEF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxyXG4gICAgICAgIHZlYzMgcCA9IHBlcm11dGUoIHBlcm11dGUoIGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjAgKSlcclxuICAgICAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjAgKSk7XHJcbiAgICBcclxuICAgICAgICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEyLnh5LHgxMi54eSksIGRvdCh4MTIuencseDEyLnp3KSksIDAuMCk7XHJcbiAgICAgICAgbSA9IG0qbSA7XHJcbiAgICAgICAgbSA9IG0qbSA7XHJcbiAgICBcclxuICAgICAgICAvLyBHcmFkaWVudHM6IDQxIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIGxpbmUsIG1hcHBlZCBvbnRvIGEgZGlhbW9uZC5cclxuICAgICAgICAvLyBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGUgb2YgNDEgKDQxKjcgPSAyODcpXHJcbiAgICBcclxuICAgICAgICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xyXG4gICAgICAgIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcclxuICAgICAgICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XHJcbiAgICAgICAgdmVjMyBhMCA9IHggLSBveDtcclxuICAgIFxyXG4gICAgICAgIC8vIE5vcm1hbGlzZSBncmFkaWVudHMgaW1wbGljaXRseSBieSBzY2FsaW5nIG1cclxuICAgICAgICAvLyBBcHByb3hpbWF0aW9uIG9mOiBtICo9IGludmVyc2VzcXJ0KCBhMCphMCArIGgqaCApO1xyXG4gICAgICAgIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoIGEwKmEwICsgaCpoICk7XHJcbiAgICBcclxuICAgICAgICAvLyBDb21wdXRlIGZpbmFsIG5vaXNlIHZhbHVlIGF0IFBcclxuICAgICAgICB2ZWMzIGc7XHJcbiAgICAgICAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcclxuICAgICAgICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xyXG4gICAgICAgIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXHJcbiAgICBmbG9hdCBzbm9pc2UoaW4gdmVjMyB2KSB7XHJcbiAgICAgICAgY29uc3QgdmVjMiAgQyA9IHZlYzIoMS4wLzYuMCwgMS4wLzMuMCkgO1xyXG4gICAgICAgIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XHJcbiAgICBcclxuICAgICAgICAvLyBGaXJzdCBjb3JuZXJcclxuICAgICAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcclxuICAgICAgICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xyXG4gICAgXHJcbiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgICAgIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xyXG4gICAgICAgIHZlYzMgbCA9IDEuMCAtIGc7XHJcbiAgICAgICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XHJcbiAgICAgICAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XHJcbiAgICBcclxuICAgICAgICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcclxuICAgICAgICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcclxuICAgICAgICB2ZWMzIHgxID0geDAgLSBpMSArIEMueHh4O1xyXG4gICAgICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcclxuICAgICAgICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxyXG4gICAgXHJcbiAgICAgICAgLy8gUGVybXV0YXRpb25zXHJcbiAgICAgICAgaSA9IG1vZDI4OShpKTtcclxuICAgICAgICB2ZWM0IHAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcclxuICAgICAgICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxyXG4gICAgICAgICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXHJcbiAgICAgICAgLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxyXG4gICAgICAgIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcclxuICAgICAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcclxuICAgIFxyXG4gICAgICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKiBucy56KTsgIC8vICBtb2QocCw3KjcpXHJcbiAgICBcclxuICAgICAgICB2ZWM0IHhfID0gZmxvb3IoaiAqIG5zLnopO1xyXG4gICAgICAgIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcclxuICAgIFxyXG4gICAgICAgIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcclxuICAgICAgICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XHJcbiAgICAgICAgdmVjNCBoID0gMS4wIC0gYWJzKHgpIC0gYWJzKHkpO1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBiMCA9IHZlYzQoIHgueHksIHkueHkgKTtcclxuICAgICAgICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xyXG4gICAgXHJcbiAgICAgICAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XHJcbiAgICAgICAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XHJcbiAgICAgICAgdmVjNCBzMCA9IGZsb29yKGIwKSoyLjAgKyAxLjA7XHJcbiAgICAgICAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XHJcbiAgICAgICAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XHJcbiAgICBcclxuICAgICAgICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XHJcbiAgICAgICAgdmVjNCBhMSA9IGIxLnh6eXcgKyBzMS54enl3KnNoLnp6d3cgO1xyXG4gICAgXHJcbiAgICAgICAgdmVjMyBwMCA9IHZlYzMoYTAueHksaC54KTtcclxuICAgICAgICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xyXG4gICAgICAgIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XHJcbiAgICAgICAgdmVjMyBwMyA9IHZlYzMoYTEuencsaC53KTtcclxuICAgIFxyXG4gICAgICAgIC8vTm9ybWFsaXNlIGdyYWRpZW50c1xyXG4gICAgICAgIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xyXG4gICAgICAgIHAwICo9IG5vcm0ueDtcclxuICAgICAgICBwMSAqPSBub3JtLnk7XHJcbiAgICAgICAgcDIgKj0gbm9ybS56O1xyXG4gICAgICAgIHAzICo9IG5vcm0udztcclxuICAgIFxyXG4gICAgICAgIC8vIE1peCBmaW5hbCBub2lzZSB2YWx1ZVxyXG4gICAgICAgIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xyXG4gICAgICAgIG0gPSBtICogbTtcclxuICAgICAgICByZXR1cm4gNDIuMCAqIGRvdCggbSptLCB2ZWM0KCBkb3QocDAseDApLCBkb3QocDEseDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmxvYXQgc25vaXNlKGluIHZlYzQgdikge1xyXG4gICAgICAgIGNvbnN0IHZlYzQgIEMgPSB2ZWM0KCAwLjEzODE5NjYwMTEyNTAxMSwgIC8vICg1IC0gc3FydCg1KSkvMjAgIEc0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC40MTQ1ODk4MDMzNzUwMzIsICAvLyAzICogRzRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0wLjQ0NzIxMzU5NTQ5OTk1OCk7IC8vIC0xICsgNCAqIEc0XHJcbiAgICBcclxuICAgICAgICAvLyBGaXJzdCBjb3JuZXJcclxuICAgICAgICB2ZWM0IGkgID0gZmxvb3IodiArIGRvdCh2LCB2ZWM0KC4zMDkwMTY5OTQzNzQ5NDc0NTEpKSApOyAvLyAoc3FydCg1KSAtIDEpLzRcclxuICAgICAgICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gT3RoZXIgY29ybmVyc1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmFuayBzb3J0aW5nIG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgYnkgQmlsbCBMaWNlYS1LYW5lLCBBTUQgKGZvcm1lcmx5IEFUSSlcclxuICAgICAgICB2ZWM0IGkwO1xyXG4gICAgICAgIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcclxuICAgICAgICB2ZWMzIGlzWVogPSBzdGVwKCB4MC56d3csIHgwLnl5eiApO1xyXG4gICAgICAgIC8vICBpMC54ID0gZG90KCBpc1gsIHZlYzMoIDEuMCApICk7XHJcbiAgICAgICAgaTAueCA9IGlzWC54ICsgaXNYLnkgKyBpc1guejtcclxuICAgICAgICBpMC55encgPSAxLjAgLSBpc1g7XHJcbiAgICAgICAgLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xyXG4gICAgICAgIGkwLnkgKz0gaXNZWi54ICsgaXNZWi55O1xyXG4gICAgICAgIGkwLnp3ICs9IDEuMCAtIGlzWVoueHk7XHJcbiAgICAgICAgaTAueiArPSBpc1laLno7XHJcbiAgICAgICAgaTAudyArPSAxLjAgLSBpc1laLno7XHJcbiAgICBcclxuICAgICAgICAvLyBpMCBub3cgY29udGFpbnMgdGhlIHVuaXF1ZSB2YWx1ZXMgMCwxLDIsMyBpbiBlYWNoIGNoYW5uZWxcclxuICAgICAgICB2ZWM0IGkzID0gY2xhbXAoIGkwLCAwLjAsIDEuMCApO1xyXG4gICAgICAgIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xyXG4gICAgICAgIHZlYzQgaTEgPSBjbGFtcCggaTAtMi4wLCAwLjAsIDEuMCApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4eFxyXG4gICAgICAgIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XHJcbiAgICAgICAgLy8gIHgzID0geDAgLSBpMyAgKyAzLjAgKiBDLnh4eHhcclxuICAgICAgICAvLyAgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEMueHh4eFxyXG4gICAgICAgIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xyXG4gICAgICAgIHZlYzQgeDIgPSB4MCAtIGkyICsgQy55eXl5O1xyXG4gICAgICAgIHZlYzQgeDMgPSB4MCAtIGkzICsgQy56enp6O1xyXG4gICAgICAgIHZlYzQgeDQgPSB4MCArIEMud3d3dztcclxuICAgIFxyXG4gICAgICAgIC8vIFBlcm11dGF0aW9uc1xyXG4gICAgICAgIGkgPSBtb2QyODkoaSk7XHJcbiAgICAgICAgZmxvYXQgajAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKGkudykgKyBpLnopICsgaS55KSArIGkueCk7XHJcbiAgICAgICAgdmVjNCBqMSA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUgKFxyXG4gICAgICAgICAgICAgICAgICAgIGkudyArIHZlYzQoaTEudywgaTIudywgaTMudywgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueiArIHZlYzQoaTEueiwgaTIueiwgaTMueiwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueSArIHZlYzQoaTEueSwgaTIueSwgaTMueSwgMS4wICkpXHJcbiAgICAgICAgICAgICAgICArIGkueCArIHZlYzQoaTEueCwgaTIueCwgaTMueCwgMS4wICkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxyXG4gICAgICAgIC8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxyXG4gICAgICAgIHZlYzQgaXAgPSB2ZWM0KDEuMC8yOTQuMCwgMS4wLzQ5LjAsIDEuMC83LjAsIDAuMCkgO1xyXG4gICAgXHJcbiAgICAgICAgdmVjNCBwMCA9IGdyYWQ0KGowLCAgIGlwKTtcclxuICAgICAgICB2ZWM0IHAxID0gZ3JhZDQoajEueCwgaXApO1xyXG4gICAgICAgIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XHJcbiAgICAgICAgdmVjNCBwMyA9IGdyYWQ0KGoxLnosIGlwKTtcclxuICAgICAgICB2ZWM0IHA0ID0gZ3JhZDQoajEudywgaXApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50c1xyXG4gICAgICAgIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xyXG4gICAgICAgIHAwICo9IG5vcm0ueDtcclxuICAgICAgICBwMSAqPSBub3JtLnk7XHJcbiAgICAgICAgcDIgKj0gbm9ybS56O1xyXG4gICAgICAgIHAzICo9IG5vcm0udztcclxuICAgICAgICBwNCAqPSB0YXlsb3JJbnZTcXJ0KGRvdChwNCxwNCkpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXHJcbiAgICAgICAgdmVjMyBtMCA9IG1heCgwLjYgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MikpLCAwLjApO1xyXG4gICAgICAgIHZlYzIgbTEgPSBtYXgoMC42IC0gdmVjMihkb3QoeDMseDMpLCBkb3QoeDQseDQpICAgICAgICAgICAgKSwgMC4wKTtcclxuICAgICAgICBtMCA9IG0wICogbTA7XHJcbiAgICAgICAgbTEgPSBtMSAqIG0xO1xyXG4gICAgICAgIHJldHVybiA0OS4wICogKCBkb3QobTAqbTAsIHZlYzMoIGRvdCggcDAsIHgwICksIGRvdCggcDEsIHgxICksIGRvdCggcDIsIHgyICkpKVxyXG4gICAgICAgICAgICAgICAgICAgICsgZG90KG0xKm0xLCB2ZWMyKCBkb3QoIHAzLCB4MyApLCBkb3QoIHA0LCB4NCApICkgKSApIDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmVjMyBzbm9pc2UzKCB2ZWMzIHggKXtcclxuICAgICAgICBmbG9hdCBzICA9IHNub2lzZSh2ZWMzKCB4ICkpO1xyXG4gICAgICAgIGZsb2F0IHMxID0gc25vaXNlKHZlYzMoIHgueSAtIDE5LjEgLCB4LnogKyAzMy40ICwgeC54ICsgNDcuMiApKTtcclxuICAgICAgICBmbG9hdCBzMiA9IHNub2lzZSh2ZWMzKCB4LnogKyA3NC4yICwgeC54IC0gMTI0LjUgLCB4LnkgKyA5OS40ICkpO1xyXG4gICAgICAgIHZlYzMgYyA9IHZlYzMoIHMgLCBzMSAsIHMyICk7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZlYzMgc25vaXNlMyggdmVjNCB4ICl7XHJcbiAgICAgICAgZmxvYXQgcyAgPSBzbm9pc2UodmVjNCggeCApKTtcclxuICAgICAgICBmbG9hdCBzMSA9IHNub2lzZSh2ZWM0KCB4LnkgLSAxOS4xICwgeC56ICsgMzMuNCAsIHgueCArIDQ3LjIsIHgudyApKTtcclxuICAgICAgICBmbG9hdCBzMiA9IHNub2lzZSh2ZWM0KCB4LnogKyA3NC4yICwgeC54IC0gMTI0LjUgLCB4LnkgKyA5OS40LCB4LncgKSk7XHJcbiAgICAgICAgdmVjMyBjID0gdmVjMyggcyAsIHMxICwgczIgKTtcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIFxyXG4gICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgIHZlYzIgc3QgPSBnbF9GcmFnQ29vcmQueHkvdV9yZXNvbHV0aW9uLnh5O1xyXG4gICAgICAgIHN0ID0gcmF0aW8oc3QsIHVfcmVzb2x1dGlvbik7XHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgZmxvYXQgZ3JpZCA9IHVfcmVzb2x1dGlvbi54LzUwLjtcclxuICAgICAgICB2ZWMyIHN0X2kgPSBmbG9vcihzdCAqIGdyaWQpL2dyaWQ7XHJcbiAgICBcclxuICAgICAgICBmbG9hdCBuID0gMC40ICsgc25vaXNlKHZlYzMoc3RfaSwgdV90aW1lKSkgKiAwLjg7XHJcbiAgICAgICAgICBcclxuICAgICAgICBjb2xvciArPSBoc3YycmdiKHZlYzMobiAqIC40MSwgMS4sIDEuKSk7XHJcbiAgICBcclxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLDEuMCk7XHJcbiAgICB9XHJcbiAgICBgXHJcbiAgfSxcclxuICBzdW46IHtcclxuICAgIGZyYWdtZW50U2hhZGVyOiBgI2lmZGVmIEdMX0VTXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICBcclxuICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XHJcbiAgICB1bmlmb3JtIHZlYzIgdV9tb3VzZTsgXHJcbiAgICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcclxuICAgIFxyXG4gICAgI2lmZGVmIEdMX0VTXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19TVFJPS0VcclxuICAgICNkZWZpbmUgRk5DX1NUUk9LRVxyXG4gICAgXHJcbiAgICBmbG9hdCBzdHJva2UoZmxvYXQgeCwgZmxvYXQgcywgZmxvYXQgdykge1xyXG4gICAgICAgIGZsb2F0IGQ9IHN0ZXAocywgeCt3Ki41KSAtIHN0ZXAocywgeC13Ki41KTtcclxuICAgICAgICByZXR1cm4gY2xhbXAoZCwgMC4sIDEuKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX0NJUkNMRVNERlxyXG4gICAgI2RlZmluZSBGTkNfQ0lSQ0xFU0RGXHJcbiAgICBcclxuICAgIGZsb2F0IGNpcmNsZVNERih2ZWMyIHN0KSB7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gbGVuZ3RoKHN0LS41KSoyLjtcclxuICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAjZW5kaWZcclxuICAgICNpZmRlZiBHTF9FU1xyXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBGTkNfRklMTFxyXG4gICAgI2RlZmluZSBGTkNfRklMTFxyXG4gICAgXHJcbiAgICBmbG9hdCBmaWxsKGZsb2F0IHgsIGZsb2F0IHNpemUpIHtcclxuICAgICAgICByZXR1cm4gMS4tc3RlcChzaXplLCB4KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2VuZGlmXHJcbiAgICAjaWZkZWYgR0xfRVNcclxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1RSSVNERlxyXG4gICAgI2RlZmluZSBGTkNfVFJJU0RGXHJcbiAgICBcclxuICAgIGZsb2F0IHRyaVNERih2ZWMyIHN0KSB7XHJcbiAgICBcclxuICAgICAgICBzdCA9IChzdCoyLi0xLikqMi47XHJcbiAgICAgICAgcmV0dXJuIG1heChhYnMoc3QueCkgKiAwLjg2NjAyNSArc3QueSAqIDAuNSwgLXN0LnkgKiAwLjUpO1xyXG4gICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgICNlbmRpZlxyXG4gICAgI2lmZGVmIEdMX0VTXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19ST1RBVEVcclxuICAgICNkZWZpbmUgRk5DX1JPVEFURVxyXG4gICAgXHJcbiAgICB2ZWMyIHJvdGF0ZSh2ZWMyIHN0LCBmbG9hdCBhKSB7XHJcbiAgICAgICAgc3QgPSBtYXQyKGNvcyhhKSwgLXNpbihhKSxcclxuICAgICAgICAgICAgICAgICAgICBzaW4oYSksIGNvcyhhKSkqKHN0LS41KTtcclxuICAgICAgICByZXR1cm4gc3QrLjU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgICNlbmRpZlxyXG4gICAgI2lmZGVmIEdMX0VTXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19QT0xZU0RGXHJcbiAgICAjZGVmaW5lIEZOQ19QT0xZU0RGXHJcbiAgICBcclxuICAgICNpZm5kZWYgUElcclxuICAgICNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBUQVVcclxuICAgICNkZWZpbmUgVEFVIDYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIGZsb2F0IHBvbHlTREYodmVjMiBzdCwgaW50IFYpIHtcclxuICAgIFxyXG4gICAgICAgIHN0ID0gc3QqMi4tMS47XHJcbiAgICAgICAgZmxvYXQgYSA9IGF0YW4oc3QueCwgc3QueSkrUEk7XHJcbiAgICAgICAgZmxvYXQgciA9IGxlbmd0aChzdCk7XHJcbiAgICAgICAgZmxvYXQgdiA9IFRBVS9mbG9hdChWKTtcclxuICAgICAgICByZXR1cm4gY29zKGZsb29yKC41K2Evdikqdi1hKSpyO1xyXG4gICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgICNlbmRpZlxyXG4gICAgI2lmZGVmIEdMX0VTXHJcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICNlbmRpZlxyXG4gICAgXHJcbiAgICAjaWZuZGVmIEZOQ19TVEFSU0RGXHJcbiAgICAjZGVmaW5lIEZOQ19TVEFSU0RGXHJcbiAgICBcclxuICAgICNpZm5kZWYgUElcclxuICAgICNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XHJcbiAgICAjZW5kaWZcclxuICAgIFxyXG4gICAgI2lmbmRlZiBUQVVcclxuICAgICNkZWZpbmUgVEFVIDYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIGZsb2F0IHN0YXJTREYodmVjMiBzdCwgaW50IFYsIGZsb2F0IHMpIHtcclxuICAgIFxyXG4gICAgICAgIHN0ID0gc3QqNC4tMi47XHJcbiAgICAgICAgZmxvYXQgYSA9IGF0YW4oc3QueSwgc3QueCkvVEFVO1xyXG4gICAgICAgIGZsb2F0IHNlZyA9IGEgKiBmbG9hdChWKTtcclxuICAgICAgICBhID0gKChmbG9vcihzZWcpICsgLjUpL2Zsb2F0KFYpICsgXHJcbiAgICAgICAgICAgIG1peChzLCAtcywgc3RlcCguNSwgZnJhY3Qoc2VnKSkpKVxyXG4gICAgICAgICAgICAqIFRBVTtcclxuICAgICAgICByZXR1cm4gYWJzKGRvdCh2ZWMyKGNvcyhhKSwgc2luKGEpKSwgXHJcbiAgICAgICAgICAgIHN0KSk7XHJcbiAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgICNpZm5kZWYgRk5DX1JBVElPXHJcbiAgICAjZGVmaW5lIEZOQ19SQVRJT1xyXG4gICAgdmVjMiByYXRpbyhpbiB2ZWMyIHN0LCBpbiB2ZWMyIHMpIHtcclxuICAgICAgICByZXR1cm4gbWl4KCB2ZWMyKChzdC54KnMueC9zLnkpLShzLngqLjUtcy55Ki41KS9zLnksc3QueSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMihzdC54LHN0LnkqKHMueS9zLngpLShzLnkqLjUtcy54Ki41KS9zLngpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAocy54LHMueSkpO1xyXG4gICAgfVxyXG4gICAgI2VuZGlmXHJcbiAgICBcclxuICAgIFxyXG4gICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgIGZsb2F0IFFSVF9QSSA9IFBJLzQuO1xyXG4gICAgICAgIHZlYzIgc3QgPSBnbF9GcmFnQ29vcmQueHkvdV9yZXNvbHV0aW9uLnh5O1xyXG4gICAgICAgIHN0ID0gcmF0aW8oc3QsIHVfcmVzb2x1dGlvbik7XHJcbiAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xyXG4gICAgXHJcbiAgICAgICAgc3QgPSBzdCoxLjU7XHJcbiAgICAgICAgc3QgPSBzdC0uMjU7XHJcbiAgICBcclxuICAgICAgICBmbG9hdCBiZyA9IHN0YXJTREYoc3QsIDE2LCAuMSk7XHJcbiAgICAgICAgY29sb3IgKz0gZmlsbChiZywgMS4zKTtcclxuICAgICAgICBmbG9hdCBsID0gMC47XHJcbiAgICAgICAgZm9yIChmbG9hdCBpID0gMC47IGkgPCA4LjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlYzIgeHkgPSByb3RhdGUoc3QsIFFSVF9QSSppKTtcclxuICAgICAgICAgICAgeHkueSAtPSAuMztcclxuICAgICAgICAgICAgZmxvYXQgdHJpID0gcG9seVNERih4eSwgMyk7XHJcbiAgICAgICAgICAgIGNvbG9yICs9IGZpbGwodHJpLCAuMyk7XHJcbiAgICAgICAgICAgIGwgKz0gc3Ryb2tlKHRyaSwgLjMsIC4wMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbG9yICo9IDEuLWw7XHJcbiAgICAgICAgZmxvYXQgYyA9IHBvbHlTREYoc3QsIDgpO1xyXG4gICAgICAgIGNvbG9yIC09IHN0cm9rZShjLCAuMTUsIC4wNCk7XHJcbiAgICBcclxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLDEuMCk7XHJcbiAgICB9YFxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHA1OiBSZWNvcmQ8c3RyaW5nLCBQNVByb3BzPiA9IHtcclxuICBzZWE6IHtcclxuICAgIHNldHVwOiBmdW5jdGlvbiBzZXR1cCAocDUsIGNhbnZhc1BhcmVudFJlZikge1xyXG4gICAgICBwNS5jcmVhdGVDYW52YXMoY2FudmFzUGFyZW50UmVmLmNsaWVudFdpZHRoLCA1MDAsIHA1LldFQkdMKS5wYXJlbnQoY2FudmFzUGFyZW50UmVmKTtcclxuICAgIH0sXHJcbiAgICB3aW5kb3dSZXNpemVkOiBmdW5jdGlvbiB3aW5kb3dSZXNpemVkIChwNSkge1xyXG4gICAgICBwNS5yZXNpemVDYW52YXMocDVbXCJjYW52YXNcIl0ucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aCwgNTAwKTtcclxuICAgIH0sXHJcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3IChwNSkge1xyXG4gICAgICBwNS5iYWNrZ3JvdW5kKDEwNTApO1xyXG4gICAgICBwNS5zdHJva2VXZWlnaHQoMyk7XHJcblxyXG4gICAgICBwNS50cmFuc2xhdGUoODAwLCAyMDAsIC05MCk7XHJcbiAgICAgIFxyXG4gICAgICBwNS5yb3RhdGVZKC05MCk7XHJcbiAgICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XHJcbiAgICAgICAgICBwNS5wdXNoKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNTsgaisrKSB7XHJcbiAgICAgICAgICBpZiAoaiA8IGkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgcDUucHVzaCgpO1xyXG4gICAgICAgICAgcDUudHJhbnNsYXRlKGkgKiA3NSwgMCwgaiAqIDc1KTtcclxuICAgICAgICAgIHA1LmJveCg3MCwgTWF0aC5zaW4ocDUuZnJhbWVDb3VudCAqIDAuMDIgKyBqKjAuNSArIGkqMC41KSAgKiA2MCArIDkwLCA3MCk7XHJcbiAgICAgICAgICBwNS5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcDUucG9wKCk7XHJcbiAgICBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgYWJvdXRQYWdlQ29udGVudCA9IHtcclxuXHJcbiAgdGV4dDogPD5cclxuICAgIDxwPlxyXG4gICAgICBUaGlzIHNpdGUgd2FzIG1hZGUgYnkgbWUsIDxBbmNob3IgaHJlZj17XCJodHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZnJhbmNlc2NvLWFyaWxsb3R0YS0xMDRhYTgxMjIvXCJ9PkZyYW5jZXNjbyBBcmlsbG90dGEuPC9BbmNob3I+IFRoaW5rIG9mIGl0IGFzIGEgZnVuIHdlZWtlbmQgcHJvamVjdCB0byBrbm93IG1lIC0gYSBzb3J0IG9mIGV4cHJlc3NpdmUgZXhwZXJpbWVudCB0aHJvdWdoIHRoZSB3ZWlyZCBjcmFwIEkgZG8uXHJcbiAgICA8L3A+XHJcbiAgICA8cD5cclxuICAgICAgSSB1c2VkIGEgbWl4IG9mIHRlY2hub2xvZ2llcyB0aGF0IEkgYW0gdmVyeSBwYXNzaW9uYXRlIGFib3V0LiBBbW9uZyB0aG9zZSB0ZWNobm9sb2dpZXMgYXJlOiBOZXh0LmpzLCBSZWFjdCwgVHlwZXNjcmlwdCwgR0xTTCwgVGhyZWUuanMsIFA1LmpzLCBGcmFtZXIvbW90aW9uLiAgXHJcbiAgICA8L3A+IFxyXG4gICAgPHA+IFxyXG4gICAgICBhbmQgbW9yZSByZWNlbnRseSB3aXRoIGRlc2t0b3AgcHVibGlzaGluZyBzb2Z0d2FyZSBsaWtlIEFsZHVzIFBhZ2VNYWtlciBpbmNsdWRpbmcgdmVyc2lvbnMgb2YgTG9yZW0gSXBzdW0uXHJcbiAgICA8L3A+XHJcbiAgPC8+XHJcbiAgXHJcbn1cclxuXHJcbmNvbnN0IHJvbGVzOiBSb2xlc1tdID0gW1xyXG4gIHtcclxuICAgIGNvbXBhbnk6IDxBbmNob3IgaHJlZj17XCJodHRwczovL3d3dy55bmFwLmNvbS9cIn0+WW9veCBOZXQtYS1Qb3J0ZXI8L0FuY2hvcj4sXHJcbiAgICB0aXRsZTogXCJGcm9udGVuZCBEZXZlbG9wZXJcIixcclxuICAgIGxvY2F0aW9uOiBcIkJvbG9nbmEsIEl0YWx5XCIsXHJcbiAgICBkYXRlOiBcIk1heSAyMDIxIC0gUHJlc2VudFwiLFxyXG4gICAgY2hpbGRyZW46IDxkaXY+XHJcbiAgICAgIDxwPlxyXG4gICAgICAgIExvcmVtIElwc3VtIGlzIHNpbXBseSBkdW1teSB0ZXh0IG9mIHRoZSBwcmludGluZyBhbmQgdHlwZXNldHRpbmcgaW5kdXN0cnkuIExvcmVtIElwc3VtIGhhcyBiZWVuIHRoZSBpbmR1c3RyeSdzIHN0YW5kYXJkIGR1bW15IHRleHQgZXZlciBzaW5jZSB0aGUgMTUwMHMsIHdoZW4gYW4gdW5rbm93biBwcmludGVyIHRvb2sgYSBnYWxsZXkgb2YgdHlwZSBhbmQgc2NyYW1ibGVkIGl0IHRvIG1ha2UgYSB0eXBlIHNwZWNpbWVuIGJvb2suIEl0IGhhcyBzdXJ2aXZlZCBub3Qgb25seSBmaXZlIGNlbnR1cmllcywgYnV0IGFsc28gdGhlIGxlYXAgaW50byBlbGVjdHJvbmljIHR5cGVzZXR0aW5nLCByZW1haW5pbmcgZXNzZW50aWFsbHkgdW5jaGFuZ2VkLiBJdCB3YXMgcG9wdWxhcmlzZWQgaW4gdGhlIDE5NjBzIHdpdGggdGhlIHJlbGVhc2Ugb2YgTGV0cmFzZXQgc2hlZXRzIGNvbnRhaW5pbmcgTG9yZW0gSXBzdW0gcGFzc2FnZXMsXHJcbiAgICAgIDwvcD4gXHJcbiAgICAgIDxwPiBcclxuICAgICAgICBhbmQgbW9yZSByZWNlbnRseSB3aXRoIGRlc2t0b3AgcHVibGlzaGluZyBzb2Z0d2FyZSBsaWtlIEFsZHVzIFBhZ2VNYWtlciBpbmNsdWRpbmcgdmVyc2lvbnMgb2YgTG9yZW0gSXBzdW0uXHJcbiAgICAgIDwvcD5cclxuICAgIDwvZGl2PiwgIFxyXG4gICAgc2hhZGVyOiA8U2hhZGVyIHNoYWRlcj17c2hhZGVycy5mdWxsc2NyZWVuRmJtfS8+XHJcbiAgfSwge1xyXG4gICAgY29tcGFueTogPEFuY2hvciBocmVmPXtcImh0dHBzOi8vd3d3LnNvdnJuLmNvbS9cIn0+U292cm48L0FuY2hvcj4sXHJcbiAgICB0aXRsZTogXCJGdWxsc3RhY2sgU29mdHdhcmUgRW5naW5lZXJcIixcclxuICAgIGxvY2F0aW9uOiBcIkxvbmRvbiwgVW5pdGVkIEtpbmdkb21cIixcclxuICAgIGRhdGU6IFwiSnVseSAyMDIwIC0gQXByaWwgMjAyMVwiLFxyXG4gICAgY2hpbGRyZW46IDw+XHJcbiAgICAgIDxwPlxyXG4gICAgICAgIExvcmVtIElwc3VtIGlzIHNpbXBseSBkdW1teSB0ZXh0IG9mIHRoZSBwcmludGluZyBhbmQgdHlwZXNldHRpbmcgaW5kdXN0cnkuIExvcmVtIElwc3VtIGhhcyBiZWVuIHRoZSBpbmR1c3RyeSdzIHN0YW5kYXJkIGR1bW15IHRleHQgZXZlciBzaW5jZSB0aGUgMTUwMHMsIHdoZW4gYW4gdW5rbm93biBwcmludGVyIHRvb2sgYSBnYWxsZXkgb2YgdHlwZSBhbmQgc2NyYW1ibGVkIGl0IHRvIG1ha2UgYSB0eXBlIHNwZWNpbWVuIGJvb2suIEl0IGhhcyBzdXJ2aXZlZCBub3Qgb25seSBmaXZlIGNlbnR1cmllcywgYnV0IGFsc28gdGhlIGxlYXAgaW50byBlbGVjdHJvbmljIHR5cGVzZXR0aW5nLCByZW1haW5pbmcgZXNzZW50aWFsbHkgdW5jaGFuZ2VkLiBJdCB3YXMgcG9wdWxhcmlzZWQgaW4gdGhlIDE5NjBzIHdpdGggdGhlIHJlbGVhc2Ugb2YgTGV0cmFzZXQgc2hlZXRzIGNvbnRhaW5pbmcgTG9yZW0gSXBzdW0gcGFzc2FnZXMsXHJcbiAgICAgIDwvcD4gXHJcbiAgICAgIDxwPiBcclxuICAgICAgICBhbmQgbW9yZSByZWNlbnRseSB3aXRoIGRlc2t0b3AgcHVibGlzaGluZyBzb2Z0d2FyZSBsaWtlIEFsZHVzIFBhZ2VNYWtlciBpbmNsdWRpbmcgdmVyc2lvbnMgb2YgTG9yZW0gSXBzdW0uXHJcbiAgICAgIDwvcD5cclxuICAgIDwvPiwgICAgXHJcbiAgICBzaGFkZXI6IDxTaGFkZXIgc2hhZGVyPXtzaGFkZXJzLnN1bn0vPlxyXG4gIH0sIHtcclxuICAgIGNvbXBhbnk6IDxBbmNob3IgaHJlZj17XCJodHRwczovL3d3dy5zb3Zybi5jb20vXCJ9PlNvdnJuPC9BbmNob3I+LFxyXG4gICAgdGl0bGU6IFwiSW1wbGVtZW50YXRpb24gRW5naW5lZXIgSUksIE1hcmtldCBEZXZcIixcclxuICAgIGxvY2F0aW9uOiBcIkxvbmRvbiwgVW5pdGVkIEtpbmdkb21cIixcclxuICAgIGRhdGU6IFwiSmFudWFyeSAyMDIwIC0gSnVuZSAyMDIwXCIsXHJcbiAgICBjaGlsZHJlbjogPD5cclxuICAgICAgPHA+XHJcbiAgICAgICAgTG9yZW0gSXBzdW0gaXMgc2ltcGx5IGR1bW15IHRleHQgb2YgdGhlIHByaW50aW5nIGFuZCB0eXBlc2V0dGluZyBpbmR1c3RyeS4gTG9yZW0gSXBzdW0gaGFzIGJlZW4gdGhlIGluZHVzdHJ5J3Mgc3RhbmRhcmQgZHVtbXkgdGV4dCBldmVyIHNpbmNlIHRoZSAxNTAwcywgd2hlbiBhbiB1bmtub3duIHByaW50ZXIgdG9vayBhIGdhbGxleSBvZiB0eXBlIGFuZCBzY3JhbWJsZWQgaXQgdG8gbWFrZSBhIHR5cGUgc3BlY2ltZW4gYm9vay4gSXQgaGFzIHN1cnZpdmVkIG5vdCBvbmx5IGZpdmUgY2VudHVyaWVzLCBidXQgYWxzbyB0aGUgbGVhcCBpbnRvIGVsZWN0cm9uaWMgdHlwZXNldHRpbmcsIHJlbWFpbmluZyBlc3NlbnRpYWxseSB1bmNoYW5nZWQuIEl0IHdhcyBwb3B1bGFyaXNlZCBpbiB0aGUgMTk2MHMgd2l0aCB0aGUgcmVsZWFzZSBvZiBMZXRyYXNldCBzaGVldHMgY29udGFpbmluZyBMb3JlbSBJcHN1bSBwYXNzYWdlcyxcclxuICAgICAgPC9wPiBcclxuICAgICAgPHA+IFxyXG4gICAgICAgIGFuZCBtb3JlIHJlY2VudGx5IHdpdGggZGVza3RvcCBwdWJsaXNoaW5nIHNvZnR3YXJlIGxpa2UgQWxkdXMgUGFnZU1ha2VyIGluY2x1ZGluZyB2ZXJzaW9ucyBvZiBMb3JlbSBJcHN1bS5cclxuICAgICAgPC9wPlxyXG4gICAgPC8+LCAgICBcclxuICAgIHNoYWRlcjogPFNoYWRlciBzaGFkZXI9e3NoYWRlcnMuZGl0aGVyVGV4dHVyZX0vPlxyXG4gIH0sIHtcclxuICAgIGNvbXBhbnk6IDxBbmNob3IgaHJlZj17XCJodHRwczovL3d3dy5zb3Zybi5jb20vXCJ9PlNvdnJuPC9BbmNob3I+LFxyXG4gICAgdGl0bGU6IFwiU29sdXRpb25zIEVuZ2luZWVyXCIsXHJcbiAgICBsb2NhdGlvbjogXCJMb25kb24sIFVuaXRlZCBLaW5nZG9tXCIsXHJcbiAgICBkYXRlOiBcIk1heSAyMDE5IC0gRGVjZW1iZXIgMjAxOVwiLFxyXG4gICAgY2hpbGRyZW46IDw+XHJcbiAgICAgIDxwPlxyXG4gICAgICAgIExvcmVtIElwc3VtIGlzIHNpbXBseSBkdW1teSB0ZXh0IG9mIHRoZSBwcmludGluZyBhbmQgdHlwZXNldHRpbmcgaW5kdXN0cnkuIExvcmVtIElwc3VtIGhhcyBiZWVuIHRoZSBpbmR1c3RyeSdzIHN0YW5kYXJkIGR1bW15IHRleHQgZXZlciBzaW5jZSB0aGUgMTUwMHMsIHdoZW4gYW4gdW5rbm93biBwcmludGVyIHRvb2sgYSBnYWxsZXkgb2YgdHlwZSBhbmQgc2NyYW1ibGVkIGl0IHRvIG1ha2UgYSB0eXBlIHNwZWNpbWVuIGJvb2suIEl0IGhhcyBzdXJ2aXZlZCBub3Qgb25seSBmaXZlIGNlbnR1cmllcywgYnV0IGFsc28gdGhlIGxlYXAgaW50byBlbGVjdHJvbmljIHR5cGVzZXR0aW5nLCByZW1haW5pbmcgZXNzZW50aWFsbHkgdW5jaGFuZ2VkLiBJdCB3YXMgcG9wdWxhcmlzZWQgaW4gdGhlIDE5NjBzIHdpdGggdGhlIHJlbGVhc2Ugb2YgTGV0cmFzZXQgc2hlZXRzIGNvbnRhaW5pbmcgTG9yZW0gSXBzdW0gcGFzc2FnZXMsXHJcbiAgICAgIDwvcD4gXHJcbiAgICAgIDxwPiBcclxuICAgICAgICBhbmQgbW9yZSByZWNlbnRseSB3aXRoIGRlc2t0b3AgcHVibGlzaGluZyBzb2Z0d2FyZSBsaWtlIEFsZHVzIFBhZ2VNYWtlciBpbmNsdWRpbmcgdmVyc2lvbnMgb2YgTG9yZW0gSXBzdW0uXHJcbiAgICAgIDwvcD5cclxuICAgIDwvPiwgICAgIFxyXG4gICAgc2hhZGVyOiA8U2hhZGVyIHNoYWRlcj17c2hhZGVycy5zaW1wbGV4Tm9pc2V9Lz5cclxuICB9LCB7XHJcbiAgICBjb21wYW55OiA8QW5jaG9yIGhyZWY9e1wiaHR0cHM6Ly93d3cuc292cm4uY29tL1wifT5Tb3ZybjwvQW5jaG9yPixcclxuICAgIHRpdGxlOiBcIk9wZXJhdGlvbnMgU3BlY2lhbGlzdFwiLFxyXG4gICAgbG9jYXRpb246IFwiTG9uZG9uLCBVbml0ZWQgS2luZ2RvbVwiLFxyXG4gICAgZGF0ZTogXCJBdWd1c3QgMjAxOCAtIE1heSAyMDE5XCIsXHJcbiAgICBjaGlsZHJlbjogPD5cclxuICAgICAgPHA+XHJcbiAgICAgICAgTG9yZW0gSXBzdW0gaXMgc2ltcGx5IGR1bW15IHRleHQgb2YgdGhlIHByaW50aW5nIGFuZCB0eXBlc2V0dGluZyBpbmR1c3RyeS4gTG9yZW0gSXBzdW0gaGFzIGJlZW4gdGhlIGluZHVzdHJ5J3Mgc3RhbmRhcmQgZHVtbXkgdGV4dCBldmVyIHNpbmNlIHRoZSAxNTAwcywgd2hlbiBhbiB1bmtub3duIHByaW50ZXIgdG9vayBhIGdhbGxleSBvZiB0eXBlIGFuZCBzY3JhbWJsZWQgaXQgdG8gbWFrZSBhIHR5cGUgc3BlY2ltZW4gYm9vay4gSXQgaGFzIHN1cnZpdmVkIG5vdCBvbmx5IGZpdmUgY2VudHVyaWVzLCBidXQgYWxzbyB0aGUgbGVhcCBpbnRvIGVsZWN0cm9uaWMgdHlwZXNldHRpbmcsIHJlbWFpbmluZyBlc3NlbnRpYWxseSB1bmNoYW5nZWQuIEl0IHdhcyBwb3B1bGFyaXNlZCBpbiB0aGUgMTk2MHMgd2l0aCB0aGUgcmVsZWFzZSBvZiBMZXRyYXNldCBzaGVldHMgY29udGFpbmluZyBMb3JlbSBJcHN1bSBwYXNzYWdlcyxcclxuICAgICAgPC9wPiBcclxuICAgICAgPHA+IFxyXG4gICAgICAgIGFuZCBtb3JlIHJlY2VudGx5IHdpdGggZGVza3RvcCBwdWJsaXNoaW5nIHNvZnR3YXJlIGxpa2UgQWxkdXMgUGFnZU1ha2VyIGluY2x1ZGluZyB2ZXJzaW9ucyBvZiBMb3JlbSBJcHN1bS5cclxuICAgICAgPC9wPlxyXG4gICAgPC8+LCBcclxuICAgIHNoYWRlcjogPFNoYWRlciBzaGFkZXI9e3NoYWRlcnMucmF5bWFyY2hpbmd9Lz5cclxuICB9XHJcbl07XHJcblxyXG5jb25zdCB0ZXJtcyA9IFtcIndyaXRpbmcgY29kZVwiLCBcImxpc3RlbmluZyB0byBtdXNpY1wiLCBcIndhdGNoaW5nIGEgZmlsbVwiLCBcInBvc3NpYmx5IHNsZWVwaW5nXCJdO1xyXG5cclxuY29uc3QgaG9tZXBhZ2VUZXh0ID0gPD5IaSwgSSdtIEZyYW4uIEFzIHlvdSByZWFkIHRoaXMsIEkgYW0gPFRleHRDYXJvdXNlbCB0ZXJtcz17dGVybXN9IGNvbG9yPXtcImhzbCgyMTJkZWcgOTAlIDY0JSlcIn0vPiBpbiA8ZGVsPkxvbmRvbjwvZGVsPiBCb2xvZ25hLCBJdGFseS48Lz5cclxuXHJcbmV4cG9ydCB7c2hhZGVycywgcDUsIHJvbGVzLCB0ZXJtcywgaG9tZXBhZ2VUZXh0LCBhYm91dFBhZ2VDb250ZW50fSJdLCJzb3VyY2VSb290IjoiIn0=